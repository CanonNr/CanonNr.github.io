<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lksun</title>
  
  
  <link href="https://lksun.cn/atom.xml" rel="self"/>
  
  <link href="https://lksun.cn/"/>
  <updated>2022-06-30T07:40:17.641Z</updated>
  <id>https://lksun.cn/</id>
  
  <author>
    <name>SunRan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Seata 分布式事务原理源码分析（一）UndoLog</title>
    <link href="https://lksun.cn/2022/06/30/Seata%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89UndoLog/"/>
    <id>https://lksun.cn/2022/06/30/Seata%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89UndoLog/</id>
    <published>2022-06-30T11:22:51.000Z</published>
    <updated>2022-06-30T07:40:17.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Seata-分布式事务原理源码分析（一）UndoLog"><a href="#Seata-分布式事务原理源码分析（一）UndoLog" class="headerlink" title="Seata 分布式事务原理源码分析（一）UndoLog"></a>Seata 分布式事务原理源码分析（一）UndoLog</h1><h2 id="什么是UndoLog？"><a href="#什么是UndoLog？" class="headerlink" title="什么是UndoLog？"></a>什么是UndoLog？</h2><p><strong>UndoLog</strong> 是 MySQL 中比较重要的事务日志之一，顾名思义是一种用于撤销回退的日志，在事务没提交之前，MySQL会先记录更新前的数据到 UndoLog 日志文件里面，当事务回滚时或者数据库崩溃时，可以利用 UndoLog 来进行回退。</p><p>主要作用有两个：</p><ol><li><p>提供回滚操作，保证<strong>原子性</strong></p><blockquote><p>MySQL事务的连个操作：commit 和 rollback；rollback</p></blockquote></li><li><p>提供多版本并发控制，保证<strong>隔离型</strong></p><blockquote><p>多个事务在操作时互不影响</p></blockquote></li></ol><p>UndoLog 存在 MySQL 的服务端中，面对微服务架构做不到共享。所以 <strong>Seata AT 模式</strong>通过 UndoLog 表实现分布式事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;branch transaction id&#x27;</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;global transaction id&#x27;</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;undo_log context,such as serialization&#x27;</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;rollback info&#x27;</span>,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;0:normal status,1:defense status&#x27;</span>,</span><br><span class="line">  `log_created` datetime(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create datetime&#x27;</span>,</span><br><span class="line">  `log_modified` datetime(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;modify datetime&#x27;</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;AT transaction mode undo table&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="UndoLogManager"><a href="#UndoLogManager" class="headerlink" title="UndoLogManager"></a>UndoLogManager</h2><p>UndoLog 统一由 <code>UndoLogManager</code> 接口管理，实现类有：<code>MySQLUndoLogManager</code> 和 <code>OracleUndoLogManager</code> ，对应了MySQL 和 Oracle 两大数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INSERT_UNDO_LOG_SQL = <span class="string">&quot;INSERT INTO &quot;</span> + UNDO_LOG_TABLE_NAME +</span><br><span class="line">            <span class="string">&quot; (&quot;</span> + ClientTableColumnsName.UNDO_LOG_BRANCH_XID + <span class="string">&quot;, &quot;</span> + ClientTableColumnsName.UNDO_LOG_XID + <span class="string">&quot;, &quot;</span></span><br><span class="line">            + ClientTableColumnsName.UNDO_LOG_CONTEXT + <span class="string">&quot;, &quot;</span> + ClientTableColumnsName.UNDO_LOG_ROLLBACK_INFO + <span class="string">&quot;, &quot;</span></span><br><span class="line">            + ClientTableColumnsName.UNDO_LOG_LOG_STATUS + <span class="string">&quot;, &quot;</span> + ClientTableColumnsName.UNDO_LOG_LOG_CREATED + <span class="string">&quot;, &quot;</span></span><br><span class="line">            + ClientTableColumnsName.UNDO_LOG_LOG_MODIFIED + <span class="string">&quot;)&quot;</span> +</span><br><span class="line">            <span class="string">&quot; VALUES (?, ?, ?, ?, ?, now(), now())&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELETE_UNDO_LOG_BY_CREATE_SQL = <span class="string">&quot;DELETE FROM &quot;</span> + UNDO_LOG_TABLE_NAME +</span><br><span class="line">            <span class="string">&quot; WHERE log_created &lt;= ? LIMIT ?&quot;</span>;</span><br></pre></td></tr></table></figure><p>以MySQL为例,存储了两条SQL语句，一条是插入一条是删除。分别用于开始全局事务后数据发生变动插入UndoLog，和事物提交或回滚后删除对应的UndoLog。</p><h2 id="何时插入UndoLog"><a href="#何时插入UndoLog" class="headerlink" title="何时插入UndoLog"></a>何时插入UndoLog</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flushUndoLogs</span><span class="params">(ConnectionProxy cp)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ConnectionContext connectionContext = cp.getContext();</span><br><span class="line">  String xid = connectionContext.getXid();</span><br><span class="line">  <span class="keyword">long</span> branchID = connectionContext.getBranchId();</span><br><span class="line"></span><br><span class="line">  BranchUndoLog branchUndoLog = <span class="keyword">new</span> BranchUndoLog();</span><br><span class="line">  branchUndoLog.setXid(xid);</span><br><span class="line">  branchUndoLog.setBranchId(branchID);</span><br><span class="line">  branchUndoLog.setSqlUndoLogs(connectionContext.getUndoItems());</span><br><span class="line"></span><br><span class="line">  UndoLogParser parser = UndoLogParserFactory.getInstance();</span><br><span class="line">  <span class="keyword">byte</span>[] undoLogContent = parser.encode(branchUndoLog);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">    LOGGER.debug(<span class="string">&quot;Flushing UNDO LOG: &#123;&#125;&quot;</span>, <span class="keyword">new</span> String(undoLogContent, Constants.DEFAULT_CHARSET));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  insertUndoLogWithNormal(xid, branchID, buildContext(parser.getName()), undoLogContent,</span><br><span class="line">                          cp.getTargetConnection());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertUndoLog</span><span class="params">(String xid, <span class="keyword">long</span> branchID, String rollbackCtx,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">byte</span>[] undoLogContent, State state, Connection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement pst = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    pst = conn.prepareStatement(INSERT_UNDO_LOG_SQL);</span><br><span class="line">    pst.setLong(<span class="number">1</span>, branchID);</span><br><span class="line">    pst.setString(<span class="number">2</span>, xid);</span><br><span class="line">    pst.setString(<span class="number">3</span>, rollbackCtx);</span><br><span class="line">    pst.setBlob(<span class="number">4</span>, BlobUtils.bytes2Blob(undoLogContent));</span><br><span class="line">    pst.setInt(<span class="number">5</span>, state.getValue());</span><br><span class="line">    pst.executeUpdate();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> SQLException)) &#123;</span><br><span class="line">      e = <span class="keyword">new</span> SQLException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> (SQLException) e;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pst != <span class="keyword">null</span>) &#123;</span><br><span class="line">      pst.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那么有个疑问，Seata是如何实现在增删改操作时自动插入UndoLog数据。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Seata-分布式事务原理源码分析（一）UndoLog&quot;&gt;&lt;a href=&quot;#Seata-分布式事务原理源码分析（一）UndoLog&quot; class=&quot;headerlink&quot; title=&quot;Seata 分布式事务原理源码分析（一）UndoLog&quot;&gt;&lt;/a&gt;Seata</summary>
      
    
    
    
    <category term="Java" scheme="https://lksun.cn/categories/Java/"/>
    
    
    <category term="分布式" scheme="https://lksun.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="Seata" scheme="https://lksun.cn/tags/Seata/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码解析(五) 解决循环依赖问题</title>
    <link href="https://lksun.cn/2022/01/25/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%94-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"/>
    <id>https://lksun.cn/2022/01/25/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%94-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</id>
    <published>2022-01-25T11:09:22.000Z</published>
    <updated>2022-06-30T07:40:17.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是依赖注入"><a href="#什么是依赖注入" class="headerlink" title="什么是依赖注入?"></a>什么是依赖注入?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如上代码，A和B相互依赖对方</p></blockquote><ul><li>注入A对象的时候发现需要B对象，那就先去注入B对象</li><li>注入B对象的时候发现需要A对象，那就先去注入A对象</li><li>注入A对象的时候发现需要B对象，那就先去注入B对象</li><li>注入B对象的时候发现需要A对象，那就先去注入A对象</li></ul><p>… 不断循环导致注入失败。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><blockquote><p><strong>一句话回答如何解决循环依赖：Spring解决循环依赖的核心思想在于提前曝光</strong></p><p>创建Bean的时候将流程分为两步走，<strong>先实例化再初始化</strong>只实例化没有初始化的叫半成品（放置在二级缓存**<code>earlySingletonObjects</code><strong>）反之则是完成品（放置在一级缓存</strong><code>singletonObjects</code>**）。</p><p>A注入对象时遇到依赖其他属性先到完成品池子寻找对象，没有则去半成品池子，半成品也没有则创建一个半成品。A对象注入时先不考虑属性完成与否，先将属性逐个注入，保证自己是个完成品并放置到一级缓存，然后B对象依赖A属性时直接从一级缓存取出即可。</p></blockquote><p>这个机制的一个前提：<strong>无论怎么填充属性，对象的内存地址是不会改变的。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;什么是依赖注入&quot;&gt;&lt;a href=&quot;#什么是依赖注入&quot; class=&quot;headerlink&quot; title=&quot;什么是依赖注入?&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://lksun.cn/categories/Java/"/>
    
    
    <category term="Spring" scheme="https://lksun.cn/tags/Spring/"/>
    
    <category term="Spring源码解析系列" scheme="https://lksun.cn/tags/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码解析(四) 初始化Bean工厂</title>
    <link href="https://lksun.cn/2022/01/21/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%9B%9B-%E5%88%9D%E5%A7%8B%E5%8C%96Bean%E5%B7%A5%E5%8E%82/"/>
    <id>https://lksun.cn/2022/01/21/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%9B%9B-%E5%88%9D%E5%A7%8B%E5%8C%96Bean%E5%B7%A5%E5%8E%82/</id>
    <published>2022-01-21T16:10:52.000Z</published>
    <updated>2022-06-30T07:40:17.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>初始化Bean工厂</strong> 这个名字起的好像有点大，在前面创建了Bean工厂后填充了一些属性，创建了BeanDifinition但是一直没有注入Bean。</p><p>本章Bean就将正式入住了。</p><blockquote><p>建议结合 “Bean的生命周期” 这个问题一起思考</p></blockquote><h2 id="抽象流程"><a href="#抽象流程" class="headerlink" title="抽象流程"></a>抽象流程</h2><h3 id="源码流程"><a href="#源码流程" class="headerlink" title="源码流程"></a>源码流程</h3><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201242209028.jpg" alt="finishBeanFactoryInitialization()" style="zoom:25%;" /><h3 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h3><p><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201242211753.png" alt="image-20220124221151814"></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="BeanDefinition-的合并机制"><a href="#BeanDefinition-的合并机制" class="headerlink" title="BeanDefinition 的合并机制"></a>BeanDefinition 的合并机制</h3><blockquote><p>在创建工厂并读取Bean配置时会创建一个<code>BeanDefinition</code>对象，<code>BeanDefinition</code>是一个高级接口，准确来说时创建为了<code>GenericBeanDefinition</code>。</p><p>在经历合并后会变成<code>RootBeanDefinition</code>。</p><p>虽然执行了<code>getMergedLocalBeanDefinition</code>方法，但是正常来说这不是真正的第一次合并。</p></blockquote><ul><li><p><code>BeanDefinition</code> 什么时候合并的？    </p><p>在调用<code>BeanFactoryPostProcessor</code>时就已经执行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] postProcessorNames =</span><br><span class="line">                    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>在根据类型获取<code>postProcessorNames</code>时，遍历所有的<code>BeanDefinitionName</code>获取合并后的<code>BeanDefinition</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br></pre></td></tr></table></figure></li><li><p>为什么要这么做？</p><blockquote><p><code>GenericBeanDefinition</code>相比较Root多了一个<code>ParentName</code>的属性，用于记录<code>Bean</code>的<code>parent</code>参数。</p><p>通过<code>GenericBeanDefinition</code>先定义好对象的父子关系，后面的<code>RootBeanDefinition</code>根据前面所定义的父子关系去创建<code>Bean</code>，没有父类直接创建，存在父类递归的去创建父类（父类也可能存在父类）。</p><p>如果不提前创建父子关系，很有可能出现创建子类时发现父类还没有创建此时就需要大量的判断和查询显然是没有两阶段机制优雅</p></blockquote></li></ul><h3 id="FactoryBean-处理机制"><a href="#FactoryBean-处理机制" class="headerlink" title="FactoryBean 处理机制"></a>FactoryBean 处理机制</h3><blockquote><p><code>FactoryBean</code> 和 <code>BeanFactory</code> 看的很像，提供的服务也很像，但是底层时完全不同的。在 Spring 容器需要针对的做出一套处理机制/</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否为FactoryBean</span></span><br><span class="line"><span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">    <span class="comment">// [1] 根据（&amp;+beanName）的规则来获取对象 </span></span><br><span class="line">    Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">    <span class="comment">// 进行类型转换</span></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">        <span class="comment">// 判断这个FactoryBean是否希望立即初始化</span></span><br><span class="line">        <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">            isEagerInit = AccessController.doPrivileged(</span><br><span class="line">                (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 只有实现SmartFactoryBean才可以定义是否急迫</span></span><br><span class="line">            isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                           ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [2] 如果希望急切的初始化，则通过beanName获取bean实例</span></span><br><span class="line">        <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// [3] 如果beanName对应的bean不是FactoryBean，只是普通的bean，通过beanName获取bean实例</span></span><br><span class="line">    getBean(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>[1]</strong>  根据（&amp;+beanName）的规则来获取对象</p><blockquote><p><code>FactoryBean</code> 是一个特殊的<code>Bean</code>！</p><p><code>FactoryBean</code> 是一个特殊的<code>Bean</code>！</p><p><code>FactoryBean</code> 是一个特殊的<code>Bean</code>！</p><p>⚠️ 重要的事情说三遍，既然也是<code>Bean</code>也是需要交予<code>Spring</code>容器管理的。正是因为<code>FactoryBean</code>的特殊性，拥有了与其他<code>Bean</code>不同<code>BeanName</code>规则（需要前缀加一个&amp;）</p></blockquote></li><li><p><strong>[2]</strong> 急切的初始化</p><blockquote><p>正常流程来说，<code>FactoryBean</code> 的对象在初始阶段是不会被注入到Spring容器的，需要在<code>getBean()</code>才会注入。</p><p>如果<code>isEagerInit = true</code> 就会立刻注入。</p><p>⚠️ 此时注入的是实际的<code>Bean</code>，不是上面所注入的<code>FactoryBean</code></p></blockquote></li><li><p><strong>[3]</strong> 普通的Bean</p><blockquote><p>不是<code>FactoryBean</code>正常执行<code>getBean()</code>即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># doGetBean</span><br><span class="line"><span class="comment">// 前面说了 FactoryBean 在BeanName起名有独特的规范</span></span><br><span class="line"><span class="comment">// 该方法就是去掉了&amp;的前缀</span></span><br><span class="line">String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提前检查单例缓存中是否有手动注册的单例对象，跟循环依赖有关联</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="comment">// 如果bean的单例对象找到了，且没有创建bean实例时要使用的参数</span></span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...省略部分源码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回对象的实例</span></span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name 如果是&amp;作为前缀</span></span><br><span class="line">    <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        <span class="comment">// 如果beanInstance是NullBean实例</span></span><br><span class="line">        <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">            <span class="comment">// 返回beanInstance</span></span><br><span class="line">            <span class="keyword">return</span> beanInstance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果beanInstance不是FactoryBean实例</span></span><br><span class="line">        <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">            <span class="comment">// 抛出Bean不是一个Factory异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果mbd不为null</span></span><br><span class="line">        <span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置mbd是否是FactoryBean标记为true</span></span><br><span class="line">            mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回beanInstance</span></span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是FactoryBean类型直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义为bean公开的对象，初始化为null</span></span><br><span class="line">    Object object = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果mbd不为null</span></span><br><span class="line">    <span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 更新mbd的是否是FactoryBean标记为true</span></span><br><span class="line">        mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从FactoryBean获得的对象缓存集中获取beanName对应的Bean对象</span></span><br><span class="line">        object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果object为null</span></span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Return bean instance from factory.</span></span><br><span class="line">        <span class="comment">// 从工厂返回Bean实例</span></span><br><span class="line">        <span class="comment">// 将beanInstance强转为FactoryBean对象</span></span><br><span class="line">        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">        <span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">        <span class="comment">// 如果是单例对象，则缓存从FactoryBean获得的对象、</span></span><br><span class="line">        <span class="comment">// 如果mbd为null&amp;&amp;该BeanFactory包含beanName的BeanDefinition对象。</span></span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="comment">//获取beanName合并后的本地RootBeanDefintiond对象</span></span><br><span class="line">            mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否是&#x27;synthetic&#x27;标记：mbd不为null &amp;&amp; 返回此bean定义是否是&quot;synthetic&quot;【一般是指只有AOP相关的prointCut配置或者</span></span><br><span class="line">        <span class="comment">// Advice配置才会将 synthetic设置为true】</span></span><br><span class="line">        <span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">        <span class="comment">// 从BeanFactory对象中获取管理的对象.如果不是synthetic会对其对象进行该工厂的后置处理</span></span><br><span class="line">        object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回为bean公开的对象</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>getObjectForBeanInstance</code> 方法可能出现三种情况：</p><ol><li>普通的Bean对象：直接返回<code>Instance</code></li><li>带有&amp;符的FactoryBean：返回工厂Bean</li><li>不带&amp;符的FactoryBean：返回对应工厂的实际Bean</li></ol></li></ul><h3 id="Bean-是否正在创建中"><a href="#Bean-是否正在创建中" class="headerlink" title="Bean 是否正在创建中"></a>Bean 是否正在创建中</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="function">doGetBean</span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(isPrototypeCurrentlyInCreation(beanName)</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isPrototypeCurrentlyInCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前正在创建的bean名称【线程本地】</span></span><br><span class="line">    Object curVal = <span class="keyword">this</span>.prototypesCurrentlyInCreation.get();</span><br><span class="line">    <span class="keyword">return</span> (curVal != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (curVal.equals(beanName) || (curVal <span class="keyword">instanceof</span> Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>❗返回<code>True</code>表示当前Bean正在创建</p><p>如果当前创建的Bean不为空且等于当前BeanName  或  当前正在创建的bean名称是Set集合，并包含该beanName</p></blockquote><h3 id="父工厂问题"><a href="#父工厂问题" class="headerlink" title="父工厂问题"></a>父工厂问题</h3><p>通过BeanName获取Object时，如果存在父工厂且当前工厂不存在该BeanName时可能就嘀咕，它是不是存在父工厂了？</p><p>解决方案就是：通过递归的方式层层查找。</p><h3 id="Bean存在依赖问题"><a href="#Bean存在依赖问题" class="headerlink" title="Bean存在依赖问题"></a>Bean存在依赖问题</h3><p>例如在Xml定义Bean时可能设定一个 <code>parent</code> 属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;student&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.lksun.debug.entity.Student&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;miaomiao&quot;</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;age&quot;</span> value=<span class="string">&quot;8&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">&lt;bean id=<span class="string">&quot;monitor&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.lksun.debug.entity.Monitor&quot;</span> parent=<span class="string">&quot;student&quot;</span> &gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;className&quot;</span> value=<span class="string">&quot;3-2&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><code>student</code>作为<code>monitor</code>的父类或者依赖对象，先有鸡还是先有蛋就很重要了。</p><p>必须先创建了依赖Bean再创建当前对象。</p><p>解决方法同样使用递归，获取当前对象是否有依赖对象，然后层层判断</p><h3 id="解析Bean-Class"><a href="#解析Bean-Class" class="headerlink" title="解析Bean Class"></a>解析Bean Class</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br></pre></td></tr></table></figure><p>获取到了Class对象后只需要一步<code>resolvedClass.newInstance();</code>就可以获取到Object，但是Spring没有直接获取。</p><h3 id="验证及准备覆盖的方法"><a href="#验证及准备覆盖的方法" class="headerlink" title="验证及准备覆盖的方法"></a>验证及准备覆盖的方法</h3><blockquote><p>todo ….</p><p>lookup-method  replace-method</p></blockquote><h3 id="实际创建bean的方法-doCreateBean"><a href="#实际创建bean的方法-doCreateBean" class="headerlink" title="实际创建bean的方法 doCreateBean()"></a>实际创建bean的方法 <code>doCreateBean()</code></h3><h4 id="根据不同的策略创建Bean"><a href="#根据不同的策略创建Bean" class="headerlink" title="根据不同的策略创建Bean"></a>根据不同的策略创建Bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br></pre></td></tr></table></figure><h4 id="获取真实Bean对象"><a href="#获取真实Bean对象" class="headerlink" title="获取真实Bean对象"></a>获取真实Bean对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object bean = instanceWrapper.getWrappedInstance();</span><br></pre></td></tr></table></figure><h4 id="加入缓存"><a href="#加入缓存" class="headerlink" title="加入缓存"></a>加入缓存</h4><blockquote><p>关于解决循环依赖相关的问题后续着重讲</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>判断一级缓存不存在当前Bean</p><p>然后执行：</p><p>1.将beanName,singletonFactory放到单例工厂的缓存(三级缓存)</p><p>2.在二级缓存删除当前Bean</p><p>3.将beanName添加已注册的单例集中</p></blockquote><h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br></pre></td></tr></table></figure><h4 id="执行初始化逻辑"><a href="#执行初始化逻辑" class="headerlink" title="执行初始化逻辑"></a>执行初始化逻辑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br></pre></td></tr></table></figure><blockquote><p>做了如下操作：</p><p>1.执行Aware接口处理器</p><p>2.BeanPostProcessor前置方法</p><p>3.调用初始化方法，先调用bean的InitializingBean接口方法，后调用bean的自定义初始化方法</p><p>4.BeanPostProcessor前置方法后置方法</p></blockquote><h4 id="注册Disposable"><a href="#注册Disposable" class="headerlink" title="注册Disposable"></a>注册Disposable</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 注册bean对象，方便后续在容器销毁的时候销毁对象</span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br></pre></td></tr></table></figure><h4 id="标记为“未创建”"><a href="#标记为“未创建”" class="headerlink" title="标记为“未创建”"></a>标记为“未创建”</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建单例后的回调,默认实现将单例标记为不在创建中</span></span><br><span class="line">afterSingletonCreation(beanName);</span><br></pre></td></tr></table></figure><h3 id="添加到一级缓存"><a href="#添加到一级缓存" class="headerlink" title="添加到一级缓存"></a>添加到一级缓存</h3><blockquote><p>等一切都完成后添加到一级缓存</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># getSingleton()</span><br><span class="line">addSingleton(beanName, singletonObject);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">// 将映射关系添加到单例对象的高速缓存中</span></span><br><span class="line">        <span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">        <span class="comment">// 移除beanName在单例工厂缓存中的数据</span></span><br><span class="line">        <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">        <span class="comment">// 移除beanName在早期单例对象的高速缓存的数据</span></span><br><span class="line">        <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">        <span class="comment">// 将beanName添加到已注册的单例集中</span></span><br><span class="line">        <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1.先添加到一级缓存</p><p>2.在三级缓存移除</p><p>3.在二级缓存移除</p><p>4.保存到单例集合中</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;初始化Bean工厂&lt;/strong&gt; 这个名字起的好像有点大，在前面创建了Bean工厂后填充了一些属性，创建了BeanDif</summary>
      
    
    
    
    <category term="Java" scheme="https://lksun.cn/categories/Java/"/>
    
    
    <category term="Spring" scheme="https://lksun.cn/tags/Spring/"/>
    
    <category term="Spring源码解析系列" scheme="https://lksun.cn/tags/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码解析(三) 注册Bean处理器对象</title>
    <link href="https://lksun.cn/2022/01/21/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%89-%E6%B3%A8%E5%86%8CBean%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>https://lksun.cn/2022/01/21/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%89-%E6%B3%A8%E5%86%8CBean%E5%A4%84%E7%90%86%E5%99%A8/</id>
    <published>2022-01-21T13:28:57.000Z</published>
    <updated>2022-06-30T07:40:17.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面讲了 <code>BeanFactoryPostProcessor</code>本文讲 <code>BeanPostProcessor</code>，两种总给人一种很像的感觉，首先我们先总结一下两者的区别（可能不全，逐步补充）。</p><table><thead><tr><th></th><th>BeanFactoryPostProcessor</th><th>BeanPostProcessor</th></tr></thead><tbody><tr><td>角色</td><td>Spring IOC 所管理的一个Bean</td><td>Spring IOC 所管理的一个Bean</td></tr><tr><td>执行时间</td><td>IOC容器启动的时候，准确来说是 <code>refresh</code>时</td><td>每次 <code>getBean</code>时都会调用</td></tr><tr><td>执行次数</td><td>有且只有一次</td><td>无数次</td></tr><tr><td>实现方式</td><td>实现 <code>BeanFactoryPostProcessor</code>接口</td><td>实现 <code>BeanPostProcessor</code>接口</td></tr><tr><td>排序</td><td>可排序</td><td>可排序</td></tr><tr><td>获取到的参数</td><td><code>ConfigurableListableBeanFactory</code> 也就是Spring 的核心BeanFactory</td><td><code>Object</code>,执行 <code>getBean</code>的对象</td></tr><tr><td>操作性</td><td>Bean工厂的操作他都能执行，例如：可以获取 <code>BeanDefinition</code>并修改；提前注入Bean对象（执行该步骤时，自定义的Bean都没有注入）；等等等等</td><td>修改当前Bean的信息</td></tr></tbody></table><p>本文主要介绍了 <code>refresh</code> 方法中的 <code>registerBeanPostProcessors(beanFactory);</code> , 用于注册Bean的处理器对象。</p><p>⚠️ 只是注册，不执行。</p><h2 id="抽象流程"><a href="#抽象流程" class="headerlink" title="抽象流程"></a>抽象流程</h2><p>其实和 <code>BeanFactoryPostProcessor</code>的调用流程类似。</p><ol><li>根据类型查询所有 <code>BeanPostProcessor</code>的实现对象，得到一个数组</li><li>记录 <code>BeanPostProcessor</code>的数量（会有一个+1的操作，因为要算上下面手动注册的 <code>BeanPostProcessorChecker</code>）</li><li>手动注册 <code>BeanPostProcessorChecker</code></li><li>准备一些容器，用于存放收集来的各种处理器</li><li>遍历 <code>BeanPostProcessor</code>的实现对象数组<ol><li>如果 <code>BeanPostProcessor</code>实现了 <code>PriorityOrdered</code>接口，获取 <code>Bean</code>对象并添加到 <code>priorityOrderedPostProcessors</code>列表（和后面的有所不同，这里添加到列表的是 <code>BeanPostProcessor</code>具体 <code>Bean</code>对象,其他都是字符串）<ol><li>如果获取到的 <code>Bean</code>对象还实现了 <code>MergedBeanDefinitionPostProcessor</code>则添加到 <code>internalPostProcessors</code>列表</li></ol></li><li>如果没有实现 <code>PriorityOrdered</code>接口，但是实现了 <code>Order</code>接口，添加到 <code>orderedPostProcessorNames</code>列表中</li><li>如果没有实现排序相关的接口，普通对象添加到 <code>nonOrderedPostProcessorNames</code>列表中</li></ol></li><li>对 <code>priorityOrderedPostProcessors</code> 进行排序，并注册</li><li>遍历 <code>orderedPostProcessorNames</code>列表<ol><li>根据 <code>ppName</code>找到对应的 <code>BeanPostProcessor</code>实例对象</li><li>添加到 <code>orderedPostProcessors</code>集合中</li><li>如果实现了 <code>MergedBeanDefinitionPostProcessor</code>接口，那么则将 <code>ppName</code>对应的 <code>bean</code>实例添加到 <code>internalPostProcessors</code>中</li></ol></li><li>对 <code>orderedPostProcessors</code>进行排序</li><li>注册实现了 <code>Ordered</code>接口的 <code>BeanPostProcessor</code>实例添加到 <code>BeanFactory</code>中</li><li>遍历 <code>nonOrderedPostProcessorNames</code> 列表</li><li>根据 <code>ppName</code>找到对应的 <code>BeanPostProcessor</code>实例对象</li><li>添加到 <code>nonOrderedPostProcessors</code>列表</li><li>如果实现了 <code>MergedBeanDefinitionPostProcessor</code> 则添加到 <code>internalPostProcessors</code>列表</li><li>遍历 <code>nonOrderedPostProcessors</code>列表进行注册</li><li>对 <code>internalPostProcessors</code> 列表进行排序，并遍历注册</li><li>最后注册 <code>ApplicationListenerDetector</code>到 <code>BeanFactory</code>中</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个流程类似于调用 <code>BeanFactoryPostProcessor</code>，通过类型获取所有的Bean处理器对象。然后根据顺序进行注册。</p><p>顺序为：</p><ol><li>实现了 <code>PriorityOrdered</code>接口的处理器对象</li><li>实现了 <code>Ordered</code>接口的处理器对象</li><li>没有实现排序的处理器对象</li><li>实现了 <code>MergedBeanDefinitionPostProcessor</code>接口的处理器对象</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面讲了 &lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;本文讲 &lt;code&gt;BeanPostProcessor&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://lksun.cn/categories/Java/"/>
    
    
    <category term="Spring" scheme="https://lksun.cn/tags/Spring/"/>
    
    <category term="Spring源码解析系列" scheme="https://lksun.cn/tags/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码解析(二) 调用Bean工厂处理器对象</title>
    <link href="https://lksun.cn/2022/01/21/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E8%B0%83%E7%94%A8BeanFactory%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>https://lksun.cn/2022/01/21/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E8%B0%83%E7%94%A8BeanFactory%E5%A4%84%E7%90%86%E5%99%A8/</id>
    <published>2022-01-21T11:10:39.000Z</published>
    <updated>2022-06-30T07:40:17.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>BeanFactoryPostProcessor</code> 是 Spring 中很重要的一种机制，本文主要介绍了 <code>BeanFactoryPostProcessor</code> 的注册与执行。</p><p>该步骤相比较创建 <code>BeanFactory</code>并注册 <code>BeanDefinition</code>要简单清晰的多，没有过多的调核心方法 <code>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</code>只有两百多行。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p><code>BeanFactoryPostProcessor</code></p><p>BeanFactory在创建完成后的后置处理器，可以自定义一些业务代码，可用于：修改BeanDefinition，提前CreateBean。其实和 <code>BeanPostProcessor</code>相似。</p></li><li><p><code>BeanDefinitionRegistryPostProcessor</code></p><p>他是 <code>BeanFactoryPostProcessor</code>的子接口，相比较他的父接口多了一个执行方法 <code>postProcessBeanDefinitionRegistry</code></p><p>优先级要大于 <code>BeanFactoryPostProcessor</code>。</p></li><li><p><code>PriorityOrdered</code> 和 <code>Ordered</code></p><p>其实都是用于定义优先级的。</p></li></ul><blockquote><p><strong>优先级</strong> 在本方法中非常重要，看似简单的代码被拉长到了两百多行就是因为优先级导致的。</p><p>上面概念中多次提到优先级这个词，下面用简单暴力的话解答一下。</p><ul><li><code>BeanDefinitionRegistryPostProcessor</code> 的优先级一定大于 <code>BeanFactoryPostProcessor</code> ，就算天塌了也是先执行 <code>BeanDefinitionRegistryPostProcessor</code>。</li><li>被定义 <code>PriorityOrdered</code> 的 <code>Bean</code> 优先级一定大于 <code>Ordered</code> 的对象。</li><li>N个对象如果同样被 <code>PriorityOrdered</code> 或者 <code>Ordered</code> 定义，则比较其值大小。</li></ul></blockquote><h2 id="抽象流程"><a href="#抽象流程" class="headerlink" title="抽象流程"></a>抽象流程</h2><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201211314390.jpg" alt="三、prepareBeanFactory()" style="zoom:10%;" /><blockquote><p>图片比较大，建议放大后对比源码观看。</p></blockquote><p>如果用简单的话总结执行步骤：</p><ul><li>第一步：执行预设的 BeanDefinitionRegistryPostProcessor 对象（大部分情况下没有预设对象）</li><li>第二步：执行现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessor</li><li>第三步：执行实现了Ordered接口的BeanDefinitionRegistryPostProcessor</li><li>第四步：执行剩余的BeanDefinitionRegistryPostProcessor</li><li>第五步：查询实现 BeanFactoryPostProcessor 接口的对象，根据是否已执行、是否实现PriorityOrdered或Ordered接口去分类，分别加入不同的列表，用于最后统一的执行</li><li>第六步：统一遍历执行前面收集到的处理器对象</li><li>第七步：执行结束，清理元数据缓存</li></ul><h2 id="如何预设的处理器对象"><a href="#如何预设的处理器对象" class="headerlink" title="如何预设的处理器对象"></a>如何预设的处理器对象</h2><p>前面有说过，在 <code>invokeBeanFactoryPostProcessors</code>中将 <code>getBeanFactoryPostProcessors()</code>作为参数传递给了 <code>invokeBeanFactoryPostProcessors</code>。</p><p>只需要在执行此步骤之前将前置处理器添加到 <code>BeanFactoryPostProcessors</code>中即可（⚠️ 此处的 <code>BeanFactoryPostProcessors</code>有一个 <code>s</code>，是一个列表）。</p><p>例如：</p><ul><li><p><code>postProcessBeanFactory</code>是一个预留的方法，里面没有实现，我们只需要重写该方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.addBeanFactoryPostProcessor(<span class="keyword">new</span> PreBeanFactoryPostProcessor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>PreBeanFactoryPostProcessor</code>是自己实现的一个处理器对象。</p></li><li><p>当然也可以直接修改源码在任何地方执行 <code>this.addBeanFactoryPostProcessor</code></p></li></ul><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><blockquote><p>其实整个流程走下来，发现这块源码没啥难的就不详细介绍了，结合流程图和官方注释问题不大。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一句话概括：就一个执行BeanFactory处理器对象的方法，只不过因为优先级的问题搞得有点复杂。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt; 是 Spring 中很重要的一种机制，本文主要介绍了 &lt;code</summary>
      
    
    
    
    <category term="Java" scheme="https://lksun.cn/categories/Java/"/>
    
    
    <category term="Spring" scheme="https://lksun.cn/tags/Spring/"/>
    
    <category term="Spring源码解析系列" scheme="https://lksun.cn/tags/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码解析(一) 创建Bean工厂</title>
    <link href="https://lksun.cn/2022/01/20/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%80-%E5%88%9B%E5%BB%BABean%E5%B7%A5%E5%8E%82/"/>
    <id>https://lksun.cn/2022/01/20/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%80-%E5%88%9B%E5%BB%BABean%E5%B7%A5%E5%8E%82/</id>
    <published>2022-01-20T14:48:17.000Z</published>
    <updated>2022-06-30T07:40:17.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;application.xml&quot;</span>);</span><br><span class="line">User userEntity = (User) context.getBean(<span class="string">&quot;userEntity&quot;</span>);</span><br></pre></td></tr></table></figure><p>通过 <code>application.xml</code> 定义一些Bean对象，在项目启动后会由Spring的Bean工厂进行管理。</p><p>这一切都要从 <code>refresh</code> 说起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br></pre></td></tr></table></figure><p><code>obtainFreshBeanFactory()</code> 主要做了两件事:</p><ol><li><p>创建了一个容器对象——<code>DefaultListableBeanFactory</code></p></li><li><p>解析自定义的Bean对象（XML、注解等），设置到 <code>beanDefinition</code>中</p></li></ol><h2 id="抽象流程"><a href="#抽象流程" class="headerlink" title="抽象流程"></a>抽象流程</h2><p><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201201619903.png" alt="image-20220120161922862"></p><p>XML的解析过程： <code>String</code> -&gt; <code>Resource[]</code> -&gt; <code>EncodedResource</code> -&gt;<code>Document</code>-&gt;<code>BeanDefinition</code></p><h2 id="创建容器对象"><a href="#创建容器对象" class="headerlink" title="创建容器对象"></a>创建容器对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* This implementation performs an actual refresh of this context&#x27;s underlying</span></span><br><span class="line"><span class="comment">* bean factory, shutting down the previous bean factory (if any) and</span></span><br><span class="line"><span class="comment">* initializing a fresh bean factory for the next phase of the context&#x27;s lifecycle.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果存在beanFactory，则销毁beanFactory</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建DefaultListableBeanFactory对象</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        <span class="comment">// 为了序列化指定id，可以从id反序列化到beanFactory对象</span></span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        <span class="comment">// 定制beanFactory，设置相关属性，包括是否允许覆盖同名称的不同定义的对象以及循环依赖</span></span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">// 初始化documentReader,并进行XML文件读取及解析,默认命名空间的解析，自定义标签的解析</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="comment">// 将创建的Bean工厂设置到对象属性中</span></span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>refreshBeanFactory</code>首先会创建一个<code>BeanFactory</code>对象，并做一些基础的配置，最后加载<code>BeanDefinition</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title">createBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory(getInternalParentBeanFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultListableBeanFactory</code>就是最终的<code>BeanFactory</code>对象。</p><h2 id="解析自定义Bean对象"><a href="#解析自定义Bean对象" class="headerlink" title="解析自定义Bean对象"></a>解析自定义Bean对象</h2><p><code>refreshBeanFactory()</code>中有一个<code>loadBeanDefinitions()</code>，初始化<code>documentReader</code>对XML文件进行读取，最终得到<code>BeanDefinitions</code>。</p><h3 id="BeanDefinitions是什么？"><a href="#BeanDefinitions是什么？" class="headerlink" title="BeanDefinitions是什么？"></a>BeanDefinitions是什么？</h3><blockquote><p>虽然通过<code>Reader</code>对象读取解析得到了<code>BeanDefinitions</code>，但是它并不是真正意义上的Bean对象。</p><p>可以理解为是一个 XML 到 Bean 的一个中间状态，无论你的Bean通过什么方式定义只要你能解析为BeanDefinitions我都可以把他创建成一个Spring Bean。</p></blockquote><h3 id="loadBeanDefinitions"><a href="#loadBeanDefinitions" class="headerlink" title="loadBeanDefinitions"></a>loadBeanDefinitions</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个xml的beanDefinitionReader，并通过回调设置到beanFactory中</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些配置操作,省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始完成beanDefinition的加载</span></span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loadBeanDefinitions</code>方法中创建了<code>XmlBeanDefinitionReader</code>后续会通过<code>Reader</code>对象对XML进行一个读取和解析。</p><p>并且<code>loadBeanDefinitions</code>运用了重载，虽然还是那个名字但是参数发生了改变。参数从Bean工厂变成了<code>Reader</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 以Resource的方式获得配置文件的资源位置</span></span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以String的形式获得配置文件的位置</span></span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处就要看你在<code>new ClassPathXmlApplicationContext()</code>的时候参数传的是什么了，分别执行两个方法。</p><h3 id="loadBeanDefinitions-1"><a href="#loadBeanDefinitions-1" class="headerlink" title="loadBeanDefinitions"></a>loadBeanDefinitions</h3><blockquote><p>需要注意的是，执行的方法虽然还是<code>loadBeanDefinitions</code> 但是已经执行的不是原来那个对象的方法了，此时到了<code>AbstractBeanDefinitionReader</code>对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(locations, <span class="string">&quot;Location array must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">        count += loadBeanDefinitions(location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为参数是一个字符串的数组，此处对数组进行遍历，对字符串的资源地址再次执行<code>loadBeanDefinitions</code>方法。</p><p>返回结果是一个int，也就是对应的资源地址加载成功的Bean数量。</p><h3 id="loadBeanDefinitions-2"><a href="#loadBeanDefinitions-2" class="headerlink" title="loadBeanDefinitions"></a>loadBeanDefinitions</h3><blockquote><p>随后经历数次<code>loadBeanDefinitions</code>方法，直接跳过了…</p></blockquote><h3 id="doLoadBeanDefinitions"><a href="#doLoadBeanDefinitions" class="headerlink" title="doLoadBeanDefinitions"></a>doLoadBeanDefinitions</h3><blockquote><p>Spring源码中很多名字叫 doXXXX 的对象才是真正干活的对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 此处获取xml文件的document对象，这个解析过程是由documentLoader完成的,</span></span><br><span class="line">    <span class="comment">// 从String[] -string-Resource[]- resource,最终开始将resource读取成一个document文档</span></span><br><span class="line">    <span class="comment">// 根据文档的节点信息封装成一个个的BeanDefinition对象</span></span><br><span class="line">    Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">    <span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doRegisterBeanDefinitions"><a href="#doRegisterBeanDefinitions" class="headerlink" title="doRegisterBeanDefinitions"></a>doRegisterBeanDefinitions</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">    <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                                 <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    <span class="comment">// 解析BeanDefinitions</span></span><br><span class="line">    parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="parseBeanDefinitions"><a href="#parseBeanDefinitions" class="headerlink" title="parseBeanDefinitions"></a>parseBeanDefinitions</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对整个XML文件进行逐行变量</p><h3 id="parseDefaultElement"><a href="#parseDefaultElement" class="headerlink" title="parseDefaultElement"></a>parseDefaultElement</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">        importBeanDefinitionResource(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">        processAliasRegistration(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">        processBeanDefinition(ele, delegate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">        <span class="comment">// recurse</span></span><br><span class="line">        doRegisterBeanDefinitions(ele);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据标签的类型进行解析，<code>&lt;bean&gt;&lt;/bean&gt;</code>自然会执行<code>processBeanDefinition</code></p><h3 id="processBeanDefinition"><a href="#processBeanDefinition" class="headerlink" title="processBeanDefinition"></a>processBeanDefinition</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the given bean element, parsing the bean definition</span></span><br><span class="line"><span class="comment"> * and registering it with the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// beanDefinitionHolder是beanDefinition对象的封装类，封装了BeanDefinition，bean的名字和别名，用它来完成向IOC容器的注册</span></span><br><span class="line">    <span class="comment">// 得到这个对象就意味着beandefinition是通过BeanDefinitionParserDelegate</span></span><br><span class="line">    <span class="comment">// 对xml元素的信息按照spring的bean规则进行解析得到的</span></span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">            <span class="comment">// 向ioc容器注册解析得到的beandefinition的地方</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                                     bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        <span class="comment">// 在beandefinition向ioc容器注册完成之后，发送消息</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="registerBeanDefinition"><a href="#registerBeanDefinition" class="headerlink" title="registerBeanDefinition"></a>registerBeanDefinition</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   <span class="comment">// 获取BeanName</span></span><br><span class="line">   String beanName = definitionHolder.getBeanName();</span><br><span class="line">   <span class="comment">// 使用beanName做唯一标识注册</span></span><br><span class="line">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">   <span class="comment">// 注册所有的别名</span></span><br><span class="line">   String[] aliases = definitionHolder.getAliases();</span><br><span class="line">   <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">         registry.registerAlias(beanName, alias);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="registerBeanDefinition-1"><a href="#registerBeanDefinition-1" class="headerlink" title="registerBeanDefinition"></a>registerBeanDefinition</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 ....</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Still in startup registration phase</span></span><br><span class="line">        <span class="comment">// 注册beanDefinition</span></span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">        <span class="comment">// 记录beanName</span></span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">        removeManualSingletonName(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>registerBeanDefinition</code>已经回到了<code>DefaultListableBeanFactory</code>方法，正常执行来说主要会做如下操作：</p><ul><li>将解析成功的Bean对象名称加到<code>beanDefinitionNames</code>的列表中</li><li>将BeanName和BeanDefinition的键值对存放在<code>beanDefinitionMap</code>中</li></ul><p>至此，就将五花八门的自定义Bean解析为了<code>BeanDefinition</code>，并存放在了<code>BeanFactory</code>中，后续需要加载某个<code>Bean</code>时只需要根据名称到<code>map</code>中找到对应的<code>BeanDefinition</code>即可，然后执行<code>doCreateBean</code>方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c</summary>
      
    
    
    
    <category term="Java" scheme="https://lksun.cn/categories/Java/"/>
    
    
    <category term="Spring" scheme="https://lksun.cn/tags/Spring/"/>
    
    <category term="Spring源码解析系列" scheme="https://lksun.cn/tags/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构源码解析(七) 整数集合</title>
    <link href="https://lksun.cn/2022/01/20/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%83-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <id>https://lksun.cn/2022/01/20/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%83-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</id>
    <published>2022-01-20T12:54:23.000Z</published>
    <updated>2022-06-30T07:40:17.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>整数集合（intset）是一个有序的、存储整型数据的结构。</p><p>关键字：<strong>有序的</strong>、<strong>整型的</strong></p><img src="https://tech.youzan.com/content/images/2021/12/image2021-12-9_12-47-9.png" alt="img" style="zoom:50%;" /><p>conding决定了的element的长度，对应关系如下</p><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201201256850.png" alt="img" style="zoom:50%;" /><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><h3 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span>  </span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//元素个数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 柔性数组，根据encoding 决定几个字节表示一个数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>可以看到底层是通过<strong>数组</strong>实现</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">intsetFind</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;  </span><br><span class="line">　　<span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value); <span class="comment">//判断编码方式</span></span><br><span class="line">　　<span class="comment">//编码方式如果大于当前intset的编码方式，直接返回0。否则调用intsetSearch函数进行查找</span></span><br><span class="line">　　<span class="keyword">return</span> valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="title">intsetSearch</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint32_t</span> *pos)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, max = intrev32ifbe(is-&gt;length)<span class="number">-1</span>, mid = <span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">int64_t</span> cur = <span class="number">-1</span>;  </span><br><span class="line">    <span class="comment">/*如果intset中没有元素，直接返回0 */</span></span><br><span class="line">    <span class="keyword">if</span> (intrev32ifbe(is-&gt;length) == <span class="number">0</span>) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 如果元素大于最大值或者小于最小值，直接返回0 */</span></span><br><span class="line">    <span class="keyword">if</span> (value &gt; _intsetGet(is,max)) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (pos) *pos = intrev32ifbe(is-&gt;length);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; _intsetGet(is,<span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123; <span class="comment">//二分查找该元素  </span></span><br><span class="line">      mid = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)min + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)max) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      cur = _intsetGet(is,mid);</span><br><span class="line">    <span class="keyword">if</span> (value &gt; cur) &#123;  </span><br><span class="line">      min = mid+<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">      max = mid<span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123; <span class="comment">//查找到返回1，未查找到返回0  </span></span><br><span class="line">      <span class="keyword">if</span> (pos) *pos = mid;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (pos) *pos = min;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实比较简单，就是先做了一些基础的结构判断，因为是有序的可以通过二分查找快速查询。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这应该是最简单的一个类型了，就是一个基于数组的有序集合，增删改查都使用到了二分查找。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul><li><a class="link"   href="https://tech.youzan.com/redisyuan-ma-jie-xi/" >Redis源码解析 - 有赞技术团队<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;整数集合（intset）是一个有序的、存储整型数据的结构。&lt;/p&gt;
&lt;p&gt;关键字：&lt;strong&gt;有序的&lt;/strong&gt;、&lt;strong&gt;</summary>
      
    
    
    
    <category term="Redis" scheme="https://lksun.cn/categories/Redis/"/>
    
    
    <category term="源码" scheme="https://lksun.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Redis数据结构源码解析系列" scheme="https://lksun.cn/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构源码解析(六) 快速列表</title>
    <link href="https://lksun.cn/2022/01/20/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%85%AD-%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8/"/>
    <id>https://lksun.cn/2022/01/20/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%85%AD-%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8/</id>
    <published>2022-01-20T09:25:37.000Z</published>
    <updated>2022-06-30T07:40:17.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面分别介绍了：双向链表和压缩列表，两者作为老版本中List类型的底层实现，但是在3.2版本后被本文主角取代。</p><p>基于两者的优劣，衍生了本文的主角——快速列表</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>quickList</code> 实际上是 <code>zipList </code>和 <code>linkedList </code>的混合体，它将 <code>linkedList </code>按段切分，每一段使用 <code>zipList </code>来紧凑存储，多个 <code>zipList </code>之间使用双向指针串接起来。</p><p>简单来说：将多个压缩列表组成一个链表就是快速列表了。</p><h3 id="为什么这么做"><a href="#为什么这么做" class="headerlink" title="为什么这么做"></a>为什么这么做</h3><p><code>zipList</code> 实现是基于数组，相比较双向链表最大的提升就是减少了内存的碎片，这点对于一个基于内存的高性能存储时很重要的，但是它带来的问题也很严峻，列表元素当达到一定的量级就可能出现问题：</p><ul><li>很难找到那么大的连续内存空间：如果一个压缩列表无限大，虽然服务器可用内存好友但是因为没有足够的连续内存也会出现问题。</li><li>当列表足够大时，每一次的插入和删除操作需要频繁的申请和释放内存，产生大量的数据拷贝。</li></ul><p>所以遵循着分治原则，将一个大的列表拆分成N个小的列表通过指针首尾相接就有了—— QuickList 快速列表。</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><h3 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    <span class="comment">// 尾结点</span></span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="comment">// 压缩列表的个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">    <span class="comment">// 快速列表的个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;          <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line">    <span class="comment">// 单个节点的填充因子</span></span><br><span class="line">    <span class="keyword">int</span> fill : QL_FILL_BITS;              <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : QL_COMP_BITS; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bookmark_count: QL_BM_BITS;</span><br><span class="line">    quicklistBookmark bookmarks[];</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure><h3 id="quicklistNode"><a href="#quicklistNode" class="headerlink" title="quicklistNode"></a>quicklistNode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 主体 也就是 ziplist 压缩列表</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;</span><br><span class="line">    <span class="comment">/* 下面是一些节点的统计属性 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure><blockquote><ul><li>prev: 指向链表前一个节点的指针。</li><li>next: 指向链表后一个节点的指针。</li><li>zl: 数据指针。如果当前节点的数据没有压缩，那么它指向一个ziplist结构；否则，它指向一个quicklistLZF结构。</li><li>sz: 表示zl指向的ziplist的总大小（包括 <code>zlbytes</code>, <code>zltail</code>, <code>zllen</code>, <code>zlend</code>和各个数据项）。需要注意的是：如果ziplist被压缩了，那么这个sz的值仍然是压缩前的ziplist大小。</li><li>count: 表示ziplist里面包含的数据项个数。这个字段只有16bit。稍后我们会一起计算一下这16bit是否够用。</li><li>encoding: 表示ziplist是否压缩了（以及用了哪个压缩算法）。目前只有两种取值：2表示被压缩了（而且用的是LZF压缩算法），1表示没有压缩。</li><li>container: 是一个预留字段。本来设计是用来表明一个quicklist节点下面是直接存数据，还是使用ziplist存数据，或者用其它的结构来存数据（用作一个数据容器，所以叫container）。但是，在目前的实现中，这个值是一个固定的值2，表示使用ziplist作为数据容器。</li><li>recompress: 当我们使用类似lindex这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置recompress=1做一个标记，等有机会再把数据重新压缩。</li><li>attempted_compress: 这个值只对Redis的自动化测试程序有用。我们不用管它。</li><li>extra: 其它扩展字段。目前Redis的实现里也没用上。</li></ul></blockquote><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><code>quicklist</code>可以选择在头部或者尾部进行插入(<code>quicklistPushHead</code>和 <code>quicklistPushTail</code>)，而不管是在头部还是尾部插入数据，都包含两种情况：</p><ul><li>如果头节点（或尾节点）上ziplist大小没有超过限制（即 <code>_quicklistNodeAllowInsert</code>返回1），那么新数据被直接插入到ziplist中（调用 <code>ziplistPush</code>）。</li><li>如果头节点（或尾节点）上 <code>ziplist</code>太大了，那么新创建一个quicklistNode节点（对应地也会新创建一个ziplist），然后把这个新创建的节点插入到quicklist双向链表中。</li></ul><p><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201201029802.png" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>一个基于压缩列表和链表实现的数据结构，本质用于解决单纯的链表和压缩列表所遇到的一些内存上问题。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul><li><a class="link"   href="https://www.cnblogs.com/hunternet/p/12624691.html" >Redis数据结构——快速列表(quicklist) <i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在前面分别介绍了：双向链表和压缩列表，两者作为老版本中List类型的底层实现，但是在3.2版本后被本文主角取代。&lt;/p&gt;
&lt;p&gt;基于两者的优</summary>
      
    
    
    
    <category term="Redis" scheme="https://lksun.cn/categories/Redis/"/>
    
    
    <category term="源码" scheme="https://lksun.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Redis数据结构源码解析系列" scheme="https://lksun.cn/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构源码解析(五) 双向链表</title>
    <link href="https://lksun.cn/2022/01/19/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%94-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>https://lksun.cn/2022/01/19/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%94-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-19T23:20:22.000Z</published>
    <updated>2022-06-30T07:40:17.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Redis3.2版本之前，List 类型的实现是由：压缩列表+双向链表实现的，在3.2版本之后取缔了双向链表。</p><p>取缔的原因也很简单，在压缩列表中有讲到。</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>其实双向链表还是很常见的，也没什么不同就是首尾相接的一个个节点。</p><h3 id="listNode"><a href="#listNode" class="headerlink" title="listNode"></a>listNode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头指针</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾指针</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 比对函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><h2 id="优劣分析"><a href="#优劣分析" class="headerlink" title="优劣分析"></a>优劣分析</h2><ul><li>双向链表linkedlist便于在表的两端进行push和pop操作，在插入节点上复杂度很低，但是它的内存开销比较大。</li><li>它在每个节点上除了要保存数据之外，还要额外保存两个指针；</li><li>双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Redis 实现了自己的双端链表结构。</li><li>双端链表主要有两个作用：<ul><li>作为 Redis 列表类型的底层实现之一（3.2后弃用）</li><li>作为通用数据结构，被其他功能模块所使用；</li></ul></li><li>双端链表及其节点的性能特性如下：<ul><li>节点带有前驱和后继指针，访问前驱节点和后继节点的复杂度为 <strong>O</strong>(<strong>1</strong>) ，并且对链表的迭代可以在从表头到表尾和从表尾到表头两个方向进行；</li><li>链表带有指向表头和表尾的指针，因此对表头和表尾进行处理的复杂度为 <strong>O</strong>(<strong>1</strong>)；</li><li>链表带有记录节点数量的属性，所以可以在 <strong>O</strong>(<strong>1</strong>)复杂度内返回链表的节点数量（长度）；</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Redis3.2版本之前，List 类型的实现是由：压缩列表+双向链表实现的，在3.2版本之后取缔了双向链表。&lt;/p&gt;
&lt;p&gt;取缔的原因也</summary>
      
    
    
    
    <category term="Redis" scheme="https://lksun.cn/categories/Redis/"/>
    
    
    <category term="源码" scheme="https://lksun.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Redis数据结构源码解析系列" scheme="https://lksun.cn/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构源码解析(四) 压缩列表</title>
    <link href="https://lksun.cn/2022/01/19/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%9B%9B-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/"/>
    <id>https://lksun.cn/2022/01/19/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%9B%9B-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</id>
    <published>2022-01-19T22:18:42.000Z</published>
    <updated>2022-06-30T07:40:17.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结合Java对比Redis的压缩列表"><a href="#结合Java对比Redis的压缩列表" class="headerlink" title="结合Java对比Redis的压缩列表"></a>结合Java对比Redis的压缩列表</h2><p>说到Java中的列表，我们可能会快想到 <code>ArrayList</code>和 <code>LinkedList</code>，他们俩的区别在于一个是数组实现一个是链表实现。对于数组和链表都有各自的优劣。</p><p>回到Redis的列表同样也可以使用数组和列表去实现，Redis中有实现 <code>listNode</code> 和 <code>list</code> 结构，使用了链表结果但是这只是用于服务端存放运行数据，不存放开发者存储的数据。</p><p>原因很简单：</p><ul><li>链表在元素过多的时候确实可以提高插入的效率的优势，但是他对内存的管理不够优秀，会产生大量的内存碎片。内存碎片在大量执行内存操作的Redis中显然是不友好的。</li><li>链表的 <code>Node</code> 结构中前置节点和后置节点指针属性太多，造成内存的浪费！（真的是把勤俭持家发挥到了极致，从来没考虑过这个东西可能会浪费多少内存）</li></ul><p>就如上两个问题在Redis中使用了数组作为压缩列表的底层实现。Redis自己定义了一个规范(或者叫格式?)，将数据整齐的安排好，有统一的插入与查询方法，保证即使列表被压缩在了数组中也能完整的读取。</p><h2 id="抽象结构"><a href="#抽象结构" class="headerlink" title="抽象结构"></a>抽象结构</h2><p>先抽象的看一下，我前面所说的规范、格式大致是个什么样子</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>在数组中基本以如下格式进行存储</p><blockquote><p><code>&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;</code></p></blockquote><ul><li><code>zlbytes</code> :记录整个列表的占用字节数，也包括了自身的4个字节</li><li><code>zltail</code>：记录从第一个节点到最后一个节点的偏移量，用于反向的遍历</li><li><code>zllen</code>：节点个数，如果超过2^16 -1 时就无法记录节点个数了，此时统计需要O(N)遍历</li><li><code>entry</code>：就是存储客户端数据的节点</li><li><code>zlend</code>：一个标记位，类似于字符串中说到的 <code>\0</code>，仅仅是用于记录结束点</li></ul><h3 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h3><p><code>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code></p><p><code>prevlen</code>：前驱节点的长度</p><p><code>encoding</code>：当前节点的编码格式</p><p><code>entry-data</code>：真正的数据</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><h3 id="zlentry"><a href="#zlentry" class="headerlink" title="zlentry"></a>zlentry</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前置节点长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlensize; <span class="comment">/* Bytes used to encode the previous entry len*/</span></span><br><span class="line">    <span class="comment">// 前置</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlen;     <span class="comment">/* Previous entry len. */</span></span><br><span class="line">    <span class="comment">// encoding 长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lensize;        <span class="comment">/* Bytes used to encode this entry type/len.</span></span><br><span class="line"><span class="comment">                                    For example strings have a 1, 2 or 5 bytes</span></span><br><span class="line"><span class="comment">                                    header. Integers always use a single byte.*/</span></span><br><span class="line">    <span class="comment">// 内容的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;            <span class="comment">/* Bytes used to represent the actual entry.</span></span><br><span class="line"><span class="comment">                                    For strings this is just the string length</span></span><br><span class="line"><span class="comment">                                    while for integers it is 1, 2, 3, 4, 8 or</span></span><br><span class="line"><span class="comment">                                    0 (for 4 bit immediate) depending on the</span></span><br><span class="line"><span class="comment">                                    number range. */</span></span><br><span class="line">    <span class="comment">// 首部长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> headersize;     <span class="comment">/* prevrawlensize + lensize. */</span></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding;      <span class="comment">/* Set to ZIP_STR_* or ZIP_INT_* depending on</span></span><br><span class="line"><span class="comment">                                    the entry encoding. However for 4 bits</span></span><br><span class="line"><span class="comment">                                    immediate integers this can assume a range</span></span><br><span class="line"><span class="comment">                                    of values and must be range-checked. */</span></span><br><span class="line">    <span class="comment">// 当前元素的首地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;            <span class="comment">/* Pointer to the very start of the entry, that</span></span><br><span class="line"><span class="comment">                                    is, this points to prev-entry-len field. */</span></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><blockquote><p>暂时先抽象了解，后续补上</p></blockquote><h2 id="优劣分析"><a href="#优劣分析" class="headerlink" title="优劣分析"></a>优劣分析</h2><p><code>ziplist</code> 存储在一段连续的内存上，所以存储效率很高。但是，它不利于修改操作，插入和删除操作需要频繁的申请和释放内存。特别是当ziplist长度很长的时候，一次 <code>realloc</code>可能会导致大批量的数据拷贝。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>关于列表的底层实现，Java圈里貌似更多还是喜欢用链表，但是Redis使用了数组，原因是：链表会造成内存的碎片和过多的节点指针造成内存的浪费。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul><li><a class="link"   href="https://tech.youzan.com/redisyuan-ma-jie-xi/" >Redis源码解析 - 有赞技术团队<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://redisbook.readthedocs.io/en/latest/index.html" >Redis 设计与实现<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;结合Java对比Redis的压缩列表&quot;&gt;&lt;a href=&quot;#结合Java对比Redis的压缩列表&quot; class=&quot;headerlink&quot; title=&quot;结合Java对比Redis的压缩列表&quot;&gt;&lt;/a&gt;结合Java对比Redis的压缩列表&lt;/h2&gt;&lt;p&gt;说到Java</summary>
      
    
    
    
    <category term="Redis" scheme="https://lksun.cn/categories/Redis/"/>
    
    
    <category term="源码" scheme="https://lksun.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Redis数据结构源码解析系列" scheme="https://lksun.cn/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构源码解析(三) 跳跃表</title>
    <link href="https://lksun.cn/2022/01/19/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%89-%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <id>https://lksun.cn/2022/01/19/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%89-%E8%B7%B3%E8%B7%83%E8%A1%A8/</id>
    <published>2022-01-19T15:47:22.000Z</published>
    <updated>2022-06-30T07:40:17.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>跳跃表类似一个多层的链表，首先从最高层开始查找，如果下一个节点的值大于要查找的值或者下一个节点为null,则往下一层查找。通过空间换时间的策略，将时间复杂度控制在O(logn)。</p><h3 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h3><p><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201191548726.png" alt="avatar"></p><p>例如查找51这个数</p><p>首先从第一层开始查找，找到第二个节点，发现后面为null。</p><p>从第二层查找 查找到第四个节点，发现后面的节点为61，大于当前的数。</p><p>从第三层查找 查找到第六个节点 结束 一共查找四次，比遍历一次少了两次。数据量大的情况下，这个性能会提升的很明显。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li>表头：负责维护跳跃表的节点指针。</li><li>跳跃表节点：保存着元素值，以及多个层。</li><li>层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。</li><li>表尾：全部由 <code>NULL</code> 组成，表示跳跃表的末尾。</li></ul><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><h3 id="zskiplistNode"><a href="#zskiplistNode" class="headerlink" title="zskiplistNode"></a><strong>zskiplistNode</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 内容</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针，指向当前节点底层 前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 指向当前层的前一个节点</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span;<span class="comment">// forward 指向前一个节点的与当前节点的间距</span></span><br><span class="line">    &#125; level[]; <span class="comment">// level是一个数组</span></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><h3 id="zskiplist"><a href="#zskiplist" class="headerlink" title="zskiplist"></a><strong>zskiplist</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span> <span class="comment">// 分别指向头结点和尾结点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length; <span class="comment">// 跳跃表总长度</span></span><br><span class="line">    <span class="keyword">int</span> level; <span class="comment">// 跳跃表总高度</span></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><blockquote><p>其中，头节点是跳跃表的一个特殊节点，它的level数组元素个数为64。头节点在有序集合中不存储任何member和score值，ele值为NULL, score值为0；也不计入跳跃表的总长度。头节点在初始化时，64个元素的forward都指向NULL, span值都为0。</p></blockquote><h2 id="创建跳跃表"><a href="#创建跳跃表" class="headerlink" title="创建跳跃表"></a>创建跳跃表</h2><h3 id="zslCreate"><a href="#zslCreate" class="headerlink" title="zslCreate"></a>zslCreate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl)); <span class="comment">// 申请内存</span></span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>; <span class="comment">// 初创建 级数为1</span></span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>; <span class="comment">// 初创建 长度为1</span></span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>); <span class="comment">// 创建一个默认的头结点</span></span><br><span class="line">    <span class="comment">// 此处循环了32次</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ZSKIPLIST_MAXLEVEL</code> 跳跃表最大等级(默认值为32)，可以容纳2^64个元素</li><li>为跳跃表创建了一个初始的头节点，并设置了一个32层高的索引</li></ul><h2 id="创建表节点"><a href="#创建表节点" class="headerlink" title="创建表节点"></a>创建表节点</h2><h3 id="zslCreateNode"><a href="#zslCreateNode" class="headerlink" title="zslCreateNode"></a>zslCreateNode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a skiplist node with the specified number of levels.</span></span><br><span class="line"><span class="comment"> * The SDS string &#x27;ele&#x27; is referenced by the node after the call. */</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *zn =</span><br><span class="line">        zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(struct zskiplistLevel));</span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    zn-&gt;ele = ele;</span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>又是先创建节点再赋值</p></blockquote><h2 id="随机层高"><a href="#随机层高" class="headerlink" title="随机层高"></a>随机层高</h2><h3 id="zslRandomLevel"><a href="#zslRandomLevel" class="headerlink" title="zslRandomLevel"></a>zslRandomLevel</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在首节点直接拉满设置了一个层高的最大值32，但是如果每一个元素的层高都是32跳跃表也就没意义了。这个方法就是确定节点的层高，返回一个1 ~ <code>ZSKIPLIST_MAXLEVEL</code> 的数。</p><h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><p>插入节点总的来说一共四步</p><ol><li>查找插入位置</li><li>调整高度</li><li>插入节点</li><li>调整 <code>backward</code></li></ol><h3 id="zslInsert"><a href="#zslInsert" class="headerlink" title="zslInsert"></a>zslInsert</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;  </span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    <span class="comment">// 查找节点</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 随机一个层数</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    x = zslCreateNode(level,score,ele);</span><br><span class="line">    <span class="comment">//插入节点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment span for untouched levels */</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><ol><li>删除相比较会简单一些，如果插入或者查询时需要先查到删除节点的位置。</li><li>删除节点（其实就是一个链表删除元素）</li><li>是否为唯一的高节点，如果是则更新 <code>level</code>,不是则无需额外处理</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="为什么不使用红黑树"><a href="#为什么不使用红黑树" class="headerlink" title="为什么不使用红黑树"></a>为什么不使用红黑树</h3><p>引用一下原作者的话</p><blockquote><p>There are a few reasons: They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.<br>A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.<br>They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.About the Append Only durability &amp; speed, I don’t think it is a good idea to optimize Redis at cost of more code and more complexity for a use case that IMHO should be rare for the Redis target (fsync() at every command). Almost no one is using this feature even with ACID SQL databases, as the performance hint is big anyway.About threads: our experience shows that Redis is mostly I/O bound. I’m using threads to serve things from Virtual Memory. The long term solution to exploit all the cores, assuming your link is so fast that you can saturate a single core, is running multiple instances of Redis (no locks, almost fully scalable linearly with number of cores), and using the “Redis Cluster” solution that I plan to develop in the future.</p></blockquote><ul><li>简单总结一下：<ul><li>这并不会浪费太多的空间，并且树的高度可以动态调整的。</li><li>ZRANGE 和 ZREVRANGE命令，跳表性能比红黑树好</li><li>红黑树比较复杂…作者懒得实现</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Redis使用跳跃表结构存储有序集合数据,通过概率平衡实现近似平衡p叉书的存取效率。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul><li><a class="link"   href="https://tech.youzan.com/redisyuan-ma-jie-xi/" >Redis源码解析 - 有赞技术团队<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://redisbook.readthedocs.io/en/latest/index.html" >Redis 设计与实现<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;跳跃表类似一个多层的链表，首先从最高层开始查找，如果下一个节点的值大于要查找的值或者下一个节点为null,则往下一层查找。通过空间换时间的策</summary>
      
    
    
    
    <category term="Redis" scheme="https://lksun.cn/categories/Redis/"/>
    
    
    <category term="源码" scheme="https://lksun.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Redis数据结构源码解析系列" scheme="https://lksun.cn/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构源码解析(二) 字典</title>
    <link href="https://lksun.cn/2022/01/19/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E5%AD%97%E5%85%B8/"/>
    <id>https://lksun.cn/2022/01/19/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E5%AD%97%E5%85%B8/</id>
    <published>2022-01-19T11:07:28.000Z</published>
    <updated>2022-06-30T07:40:17.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对比HashMap"><a href="#对比HashMap" class="headerlink" title="对比HashMap"></a>对比HashMap</h2><p>字典的使用和底层与Java中的HashMap还是很像的，比较特殊的就是扩容方式。</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201191130646.png" alt="image-20220119113018577"></p><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 操作类型</span></span><br><span class="line">    dictType *type;  </span><br><span class="line">    <span class="comment">// 依赖的数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata; </span><br><span class="line">    <span class="comment">// Hash表,是个数组两个元素</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// -1代表没有进行rehash值，否则代表hash操作进行到了哪个索引</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">// 当前运行的迭代器数</span></span><br><span class="line">    <span class="keyword">int16_t</span> pauserehash; <span class="comment">/* If &gt;0 rehashing is paused (&lt;0 indicates coding error) */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><h3 id="dictht"><a href="#dictht" class="headerlink" title="dictht"></a>dictht</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span>  </span><br><span class="line">    <span class="comment">// 二维数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// table总大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">// 掩码=size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 已经保存的键值对</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><h3 id="dictEntry"><a href="#dictEntry" class="headerlink" title="dictEntry"></a><strong>dictEntry</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span>  </span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val; <span class="comment">//值</span></span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64; <span class="comment">//过期时间</span></span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// hash冲突的next指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><h2 id="如何应对Hash冲突"><a href="#如何应对Hash冲突" class="headerlink" title="如何应对Hash冲突"></a>如何应对Hash冲突</h2><p>既然使用了Hash表，就逃不掉Hash冲突的问题。</p><h3 id="Java中的解决方式"><a href="#Java中的解决方式" class="headerlink" title="Java中的解决方式"></a>Java中的解决方式</h3><blockquote><p>HashMap 使用了数组+链表+红黑树的底层结构，每一个节点对象都会有 <code>next</code>属性，从而形成一个链表结构。当链表长度大于8时会升级为红黑树。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实这叫<em>拉链法</em>或者叫<em>链地址法</em></p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><blockquote><p>把具有相同散列地址的关键字(同义词)值放在同一个单链表中，称为同义词链表。</p></blockquote><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><h3 id="dictAdd"><a href="#dictAdd" class="headerlink" title="dictAdd"></a>dictAdd</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add an element to the target hash table */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 新增元素,但是没有设置具体的值</span></span><br><span class="line">    dictEntry *entry = dictAddRaw(d,key,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 新增失败则返回异常</span></span><br><span class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">// 设置真实值</span></span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dictAddRaw"><a href="#dictAddRaw" class="headerlink" title="dictAddRaw"></a>dictAddRaw</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该字典是否在进行 rehash 操作，是则执行一次 rehash</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询某个Key的索引下标,其实就是查询该key是否存在</span></span><br><span class="line">    <span class="comment">// 已存在返回-1</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 是否在进行 rehash 操作中，是则插入至散列表 ht[1] 中，否则插入散列表 ht[0] </span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry)); <span class="comment">// 申请新节点内存</span></span><br><span class="line">    entry-&gt;next = ht-&gt;table[index]; <span class="comment">// 将该节点的 next 指针指向 ht-&gt;table[index] 指针指向的位置</span></span><br><span class="line">    ht-&gt;table[index] = entry; <span class="comment">// 将 ht-&gt;table[index] 指针指向该节点</span></span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>rehash</code> 会在扩容中讲述。</p><p>最关键的一个点：<code>ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0];</code>。在进行 <code>rehash</code>放入 <code>ht[1]</code>反之则 <code>ht[0]</code></p><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><h3 id="dictFetchValue"><a href="#dictFetchValue" class="headerlink" title="dictFetchValue"></a>dictFetchValue</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dictFetchValue</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="comment">// 关键在这一步,查询对应key所在的节点</span></span><br><span class="line">    he = dictFind(d,key);</span><br><span class="line">    <span class="comment">// 根据节点查询里面的value,否则返回NULL</span></span><br><span class="line">    <span class="keyword">return</span> he ? dictGetVal(he) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dictFind"><a href="#dictFind" class="headerlink" title="dictFind"></a>dictFind</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">uint64_t</span> h, idx, table;</span><br><span class="line">    <span class="comment">// 为空</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* dict is empty */</span></span><br><span class="line">    <span class="comment">// 该字典是否在进行 rehash 操作，是则执行一次 rehash</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">// 根据字典的hash函数得到key的hash值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="comment">// 循环两次,分别在ht[0]和ht[1]中查找</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        <span class="comment">// 根据hash值与掩码取table中的下标</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">// 获取到对应Entity</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="comment">// 如果出现了hash冲突会逐个遍历链表</span></span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="comment">// 判断key值是不是要查询的目标值</span></span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            <span class="comment">// 遍历下一个元素</span></span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个关键点：</p><ul><li><code>idx = h &amp; d-&gt;ht[table].sizemask;</code> ：在日常开发中这种场景我们更喜欢使用取余（%），因为快、方便；在HashMap中使用的就是取余，但是限制了数组长度为2的幂+位运算快速取余；在Redis中则是使用了掩码进行 <code>&amp;</code>运算</li></ul><h3 id="dictGetVal"><a href="#dictGetVal" class="headerlink" title="dictGetVal"></a>dictGetVal</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetVal(he) ((he)-&gt;v.val)</span></span><br></pre></td></tr></table></figure><h2 id="扩容操作"><a href="#扩容操作" class="headerlink" title="扩容操作"></a>扩容操作</h2><p>其实在前面的操作中已经看到了一些关于扩容的影子，例如什么是 <code>rehash</code>？为什么要有 <code>ht[1]</code>和 <code>ht[2]</code></p><p>其实这些都是为了实现一个机制——渐进式扩容。</p><h3 id="什么是渐进式扩容"><a href="#什么是渐进式扩容" class="headerlink" title="什么是渐进式扩容"></a>什么是渐进式扩容</h3><p>就好像一口吃不成胖子，一口气吃太多吃太快对胃不好，要慢慢吃慢慢长胖</p><blockquote><p>Redis中Hash类型使用了渐进式的扩容机制，因为遇到大Key时会对性能造成巨大的影响。<br>所以在dict对象中有这样一个属性：<code>dictht ht[2]</code> ，存放了一个长度为2的数组。</p><p><code>ht[0]</code>，是存放数据的 <code>table</code>，作为非扩容时容器；</p><p><code>ht[1]</code>，只有正在进行扩容时才会使用，它也是存放数据的table，长度为 <code>ht[0]</code>的两倍。</p><p>扩容时，单线程A负责把数据从 <code>ht[0]</code> 复制到 <code>ht[1]</code> 中。如果这时有其他线程<br>进行读操作：会先去 <code>ht[0]</code>中找，找不到再去 <code>ht[1]</code>中找。<br>进行写操作：直接写在 <code>ht[1]</code>中。<br>进行删除操作：与读类似。</p></blockquote><h3 id="扩容流程"><a href="#扩容流程" class="headerlink" title="扩容流程"></a>扩容流程</h3><p><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201191433945.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _dictExpand(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size, <span class="keyword">int</span>* malloc_failed)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (malloc_failed) *malloc_failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果此时正在扩容，或者是扩容大小小于 ht[0] 的表大小，则抛错</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    dictht n;  <span class="comment">// new了一个新的hash表</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否存在溢出可能</span></span><br><span class="line">    <span class="keyword">if</span> (realsize &lt; size || realsize * <span class="keyword">sizeof</span>(dictEntry*) &lt; realsize)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新计算的值如果和原来的 size 相等，则无效</span></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].size) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新 Hash 表，并初始化所有指针为 NULL</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (malloc_failed) &#123;</span><br><span class="line">        n.table = ztrycalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">        *malloc_failed = n.table == <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (*malloc_failed)</span><br><span class="line">            <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line"></span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化的情况，而不是进行 rehash 操作，就用 ht[0] 来接收值</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是初始化阶段,赋值后直接就结束了</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 准备第二个 Hash 表，以便执行渐进式哈希操作 */</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>redis中的key可能有成千上万，如果一次性扩容，会对性能造成巨大的影响，所以redis使用渐进式扩容，每次执行插入，删除，查找，修改等操作前，都先判断当前字典的rehash操作是否在进行，如果是在进行中，就对当前节点进行rehash操作，只执行一次。除此之外，当服务器空闲时，也会调用incrementallyRehash函数进行批量操作，每次100个节点，大概一毫秒。将rehash操作进行分而治之。</p></blockquote><h3 id="渐进式rehash流程"><a href="#渐进式rehash流程" class="headerlink" title="渐进式rehash流程"></a>渐进式rehash流程</h3><h4 id="rehash的准备工作"><a href="#rehash的准备工作" class="headerlink" title="rehash的准备工作"></a>rehash的准备工作</h4><ul><li>设置字典的 <code>rehashidx</code> 为 <code>0</code> ，标识着 <code>rehash</code> 的开始；</li><li>为 <code>ht[1]-&gt;table</code> 分配空间，大小至少为 <code>ht[0]-&gt;used</code> 的两倍；</li></ul><h4 id="dictRehash"><a href="#dictRehash" class="headerlink" title="dictRehash"></a>dictRehash</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一次最多rehash n*10个空桶 n的大小根据触发场景而定</span></span><br><span class="line">    <span class="comment">// 在添加新的元素时也会触发Rehash操作 _dictRehashStep n=1,一次最多rehash10个空桶</span></span><br><span class="line">    <span class="comment">// dictRehashMilliseconds 在给定毫秒内，对字典进行rehash的一个方法,n=100,一次最多1000个空桶</span></span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; </span><br><span class="line">    <span class="comment">// 如果不在Rehash则返回0</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 开始循环，执行</span></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line">        <span class="comment">// 为防止 rehashidx 越界，当 rehashidx 大于 ht[0] 的数组大小时，不继续执行 </span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="comment">// d-&gt;rehashidx 是记录着上一次rehash进行到了哪一个索引</span></span><br><span class="line">        <span class="comment">// 一直往下遍历,直到遇到不是空桶的就结束(前提是没有因为空桶数而终止)</span></span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为空表示当前索引rehash成功 +1</span></span><br><span class="line">            <span class="comment">// 并且空桶数+1</span></span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个桶一定是有数据的</span></span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">// 遍历桶中元素，移动元素至新表</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">// 获取在新桶时的下标</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            <span class="comment">// 此处使用了头插法</span></span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h]; </span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de; </span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理完成 设置为空</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否已经 rehash 完成</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先梳理 <code>dictRehash</code>方法，N和N*10的关系。</p><ul><li>一次 <code>dictRehash</code>方法最多迁移N个桶。</li><li>但是每次 <code>dictRehash</code>不一定都是需要迁移的，可能有些桶的数据为NULL，遇到N*10次空桶则结束（为什么这么做？不能无休止的让他遍历下去，防止过久的阻塞）</li></ul></li><li><p>关于头插法</p><ul><li><code>de-&gt;next = d-&gt;ht[1].table[h]; </code>首先将 <code>ht1</code>中的de对象的尾节点</li><li>再将de对象设置到 <code>d-&gt;ht[1].table[h]</code></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Redis 中的数据库和哈希键都基于字典来实现。</p></li><li><p>字典是由键值对构成的抽象数据结构。</p></li><li><p>Redis自己实现了一套哈希表的逻辑，与Java中的HashMap相似但是不完全一样，拿两者比较的总结一下。</p><ul><li>两者都通过拉链法解决了Hash冲突问题，只不过HashMap有升级红黑树的机制，Redis没有</li><li>Redis实现了逐渐式扩容，不会一下子把所有Key进行迁移（遇到大Key可能出现异常）；HashMap就是普通的迁移。<ul><li>逐渐式扩容使Redis底层需要使用到两个Hash表，一般情况下只使用 0 号哈希表，只有在 rehash 进行时，才会同时使用 0 号和 1 号哈希表。</li></ul></li><li>HashMap通过指定规则：数组长度为2的幂+位运算进行取数组下标；Redis使用掩码的方式。</li><li>HashMap在1.8之前为头插法，之后为尾插法；Redis中一直为头插法。</li></ul></li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul><li><a class="link"   href="https://tech.youzan.com/redisyuan-ma-jie-xi/" >Redis源码解析 - 有赞技术团队<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://redisbook.readthedocs.io/en/latest/index.html" >Redis 设计与实现<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对比HashMap&quot;&gt;&lt;a href=&quot;#对比HashMap&quot; class=&quot;headerlink&quot; title=&quot;对比HashMap&quot;&gt;&lt;/a&gt;对比HashMap&lt;/h2&gt;&lt;p&gt;字典的使用和底层与Java中的HashMap还是很像的，比较特殊的就是扩容方式。&lt;/</summary>
      
    
    
    
    <category term="Redis" scheme="https://lksun.cn/categories/Redis/"/>
    
    
    <category term="源码" scheme="https://lksun.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Redis数据结构源码解析系列" scheme="https://lksun.cn/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构源码解析(一) SDS</title>
    <link href="https://lksun.cn/2022/01/18/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%80-SDS/"/>
    <id>https://lksun.cn/2022/01/18/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%80-SDS/</id>
    <published>2022-01-18T16:25:33.000Z</published>
    <updated>2022-06-30T07:40:17.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C语言存储字符串的问题"><a href="#C语言存储字符串的问题" class="headerlink" title="C语言存储字符串的问题"></a>C语言存储字符串的问题</h2><h3 id="C语言中没有类似Java中的String高级对象"><a href="#C语言中没有类似Java中的String高级对象" class="headerlink" title="C语言中没有类似Java中的String高级对象"></a>C语言中没有类似Java中的String高级对象</h3><p>在Java中 <code>String</code>用的不亦乐乎，其自带的 <code>equals</code>、<code>split</code>、<code>charAt</code>等方法真的很方便，但是C是没有这种高级对象的。</p><p>如果在C语言中使用字符串有两种方式：</p><ol><li>使用字符串指针 <code>const char *str = &quot;hello&quot;;</code></li><li>使用数组 <code>const char str[] = &quot;hello&quot;;</code></li></ol><p>方法一最大的缺陷在于字符串定义后即不能修改，所以更多情况下还是使用数组。</p><h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>C语言中表示字符串结尾的符号是 <code>\0</code> ，如果字符串本身就具有 <code>\0</code> 字符，就会被截断，即非二进制安全。</p><h3 id="计算字符串的长度性能低"><a href="#计算字符串的长度性能低" class="headerlink" title="计算字符串的长度性能低"></a>计算字符串的长度性能低</h3><p>C语言中有一个计算字符串长度的函数 <code>strlen</code>，但这个函数与Java的不一样，需要遍历整个字符串来计算长度，时间复杂度是<em>O（n）</em>，如果需要在循环中计算，性能将十分低下。</p><h3 id="字符串拼接性能低"><a href="#字符串拼接性能低" class="headerlink" title="字符串拼接性能低"></a>字符串拼接性能低</h3><p>因为C语言字符串不记录长度，对于一个长度n的字符串来说，底层是n+1的字符数组（n是我们要存的字符，1是最后的结束符 <code>\0</code>）。</p><blockquote><p>底层虽然使用了n+1的字符数组，但是在使用 <code>strlen</code>方法的时候不会计算 <code>\0</code></p></blockquote><h2 id="Simple-Dynamic-String-简单的动态字符串"><a href="#Simple-Dynamic-String-简单的动态字符串" class="headerlink" title="Simple Dynamic String 简单的动态字符串"></a>Simple Dynamic String 简单的动态字符串</h2><p>在 <code>redis3.2</code>之前，sds只有一个类型，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len; <span class="comment">// 当前的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">// 剩余可用长度</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">// 实际存放的地方</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在后续版本中改为了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">// sds的当前长度(单位是字节)</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">// sds分配的内存大小(单位是字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">// sdshdr的类型</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">// 实际存放的地方</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; </span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; </span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p><code>sdshdr5</code>、<code>sdshdr8</code>、<code>sdshdr16</code>、<code>sdshdr32</code>、<code>sdshdr64</code> 一共五个方法，其中官方注解有些到 <code>sdshdr5</code>还没有被使用过。</p><h3 id="类型机制"><a href="#类型机制" class="headerlink" title="类型机制"></a>类型机制</h3><p>上面介绍了一共有五个 <code>sdshdrX</code>方法，看着都差不多只是 <code>len</code>和 <code>alloc</code> 类型不同，为什么要这么做呢？</p><p>其实也很简单就是省内存，而且真的是把能省就省发挥到了机制，在做业务开发的时候很少会为了这点内存再去做一套特殊的处理…</p><h4 id="节省内存"><a href="#节省内存" class="headerlink" title="节省内存"></a>节省内存</h4><p>我们已知的是 <code>len</code>和 <code>alloc</code>服务于字符串的长度，分别记录字符串长度和</p><ul><li><code>uint8</code>: 字符串的长度最大(2^8)-1  = 255</li><li><code>uint16</code>: 字符串的长度最大(2^16)-1 = 35535</li><li><code>uint32</code>: 字符串的长度最大(2^32)-1 = 4294967295</li><li><code>uint64</code>: 字符串的长度最大(2^64)-1 = 1.8446744e+19</li></ul><p>绝大多数情况下字符串的长度都不会超过35536，如果使用 <code>uint64</code>存储几十个几百就太浪费了。</p><h4 id="最大长度问题"><a href="#最大长度问题" class="headerlink" title="最大长度问题"></a>最大长度问题</h4><p>虽然类型限制了最大长度为(2^64)-1 ，但是真正限制的并不是它。</p><p><code>getBitOffsetFromArgument</code> 是一个计算偏移量防止为负或者溢出的方法。在其方法内有这么一个判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Limit offset to server.proto_max_bulk_len (512MB in bytes by default) */</span></span><br><span class="line"><span class="keyword">if</span> ((loffset &lt; <span class="number">0</span>) || (loffset &gt;&gt; <span class="number">3</span>) &gt;= server.proto_max_bulk_len)</span><br><span class="line">&#123;</span><br><span class="line">    addReplyError(c,err);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码注释可以看到，他是设置了512MB的一个长度限制，超出会返回异常。</p><p>在 <code>config.c</code> 文件中会对配置对象统一的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createLongLongConfig(<span class="string">&quot;proto-max-bulk-len&quot;</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, <span class="number">1024</span>*<span class="number">1024</span>, LONG_MAX, server.proto_max_bulk_len, <span class="number">512ll</span>*<span class="number">1024</span>*<span class="number">1024</span>, MEMORY_CONFIG, <span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="comment">/* Bulk request max size */</span></span><br></pre></td></tr></table></figure><h3 id="字符串的追加与扩容"><a href="#字符串的追加与扩容" class="headerlink" title="字符串的追加与扩容"></a>字符串的追加与扩容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">&quot;hello world&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> APPEND msg <span class="string">&quot; again!&quot;</span></span></span><br><span class="line">(integer) 18</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GET msg</span></span><br><span class="line">&quot;hello world again!&quot;</span><br></pre></td></tr></table></figure><p>如上执行了一个简单的字符串追加工作。接下来以伪代码的形式介绍整个过程经历了什么。</p><h4 id="SET-命令，创建一个SDS对象"><a href="#SET-命令，创建一个SDS对象" class="headerlink" title="SET 命令，创建一个SDS对象"></a>SET 命令，创建一个SDS对象</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    len = <span class="number">11</span>;</span><br><span class="line">    <span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    buf = <span class="string">&quot;hello world\0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行-APPEND-命令"><a href="#执行-APPEND-命令" class="headerlink" title="执行 APPEND 命令"></a>执行 APPEND 命令</h4><p>此时相应的 <code>sdshdr</code> 被更新，字符串 <code>&quot; again!&quot;</code> 会被追加到原来的 <code>&quot;hello world&quot;</code> 之后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    len = <span class="number">18</span>;</span><br><span class="line">    <span class="built_in">free</span> = <span class="number">18</span>;</span><br><span class="line">    buf = <span class="string">&quot;hello world again!\0                  &quot;</span>;     <span class="comment">// 空白的地方为预分配空间，共 18 + 18 + 1 个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，<code>free</code>从0-&gt;18，<code>len</code>从11-&gt;18，这次扩容整体从11-&gt;22（18-11+18）。</p><p>具体代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);      <span class="comment">// 获取当前字符串的长度</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);      <span class="comment">// 扩容</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);       <span class="comment">// 内存拷贝</span></span><br><span class="line">    sdssetlen(s, curlen+len);       <span class="comment">// 更新len属性</span></span><br><span class="line">    s[curlen+len] = <span class="string">&#x27;\0&#x27;</span>;           <span class="comment">// 末尾追加一个\0</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;  <span class="comment">//定义两个 sdshdr 结构体指针</span></span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s); <span class="comment">// 获取 s 目前空闲空间长度</span></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen, reqlen; <span class="comment">// len为扩展前长度,newlen为扩展后长度</span></span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK; <span class="comment">// 用作sdsType的判断</span></span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line">    <span class="keyword">size_t</span> usable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span> </span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s; <span class="comment">// 如果可用空间大于添加的长度，直接返回</span></span><br><span class="line"></span><br><span class="line">    len = sdslen(s);<span class="comment">// 获取 s 目前已占用空间的长度</span></span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);  <span class="comment">//结构体指针赋值</span></span><br><span class="line">    reqlen = newlen = (len+addlen); <span class="comment">// 复制扩展后长度,原长度+扩展的长度数</span></span><br><span class="line">    assert(newlen &gt; len);   <span class="comment">/* Catch size_t overflow */</span></span><br><span class="line">    <span class="comment">// 开始设定扩展后长度</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">// 如果新长度小于SDS_MAX_PREALLOC(1M),新长度直接翻倍</span></span><br><span class="line">        <span class="comment">// 这也就是上面为什么从11-&gt;22</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则每次新增一个SDS_MAX_PREALLOC单位也就是1M</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时有了新长度需要重新获取一下sds的类型,也就是sdshdr5,sdshdr8...</span></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="comment">// 作者示意不要使用sdshdr5,会变转换为sdshdr8</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    assert(hdrlen + newlen + <span class="number">1</span> &gt; reqlen);  <span class="comment">/* Catch size_t overflow */</span></span><br><span class="line">    <span class="comment">// 对比扩容前后类型是否改变，做对应的处理，不重要</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</span><br><span class="line">        <span class="comment">// 没有改变,在原空间分配</span></span><br><span class="line">        newsh = s_realloc_usable(sh, hdrlen+newlen+<span class="number">1</span>, &amp;usable);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can&#x27;t use realloc */</span></span><br><span class="line">        <span class="comment">// 重新分配空间</span></span><br><span class="line">        <span class="comment">// 并删除原空间</span></span><br><span class="line">        newsh = s_malloc_usable(hdrlen+newlen+<span class="number">1</span>, &amp;usable);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    usable = usable-hdrlen<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (usable &gt; sdsTypeMaxSize(type))</span><br><span class="line">        usable = sdsTypeMaxSize(type);</span><br><span class="line">    sdssetalloc(s, usable);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h2><p>在Redis中为了进一步的节省内存还为SDS设置了三种编码格式：</p><ul><li><code>OBJ_ENCODING_EMBSTR</code>：长度小于44字节的字符串，该编码中 <code>RedisObject</code>、<code>SDS</code>放置在连续的内存中。</li><li><code>OBJ_ENCODING_RAW</code>：长度大于44字节,除此之外与 <code>OBJ_ENCODING_EMBSTR</code>区别仅在于是否为连续内存</li><li><code>OBJ_ENCODING_INT</code>: 有时候我们会在String寸INT类型的自然数，例如一个手机号如果为字符串则需要11字节，如果使用long long 只需要8字节。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Redis 的字符串表示为 <code>sds</code> ，而不是 C 字符串（以 <code>\0</code> 结尾的 <code>char*</code>），相比较有如下特性<ul><li>在计算字符长度时更高效，直接读取 <code>len</code>熟悉为O(1)复杂度，传统C语言需要逐个遍历为O(n)</li><li>提供更高效的扩容机制，牺牲一部分内存的情况下换取更快的追加速度</li><li>二进制安全，不强制通过 <code>\0</code>作为结尾。也就是说在SDS中可以存储任何值</li></ul></li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul><li><a class="link"   href="https://tech.youzan.com/redisyuan-ma-jie-xi/" >Redis源码解析 - 有赞技术团队<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://redisbook.readthedocs.io/en/latest/index.html" >Redis 设计与实现<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://juejin.cn/post/6847902218528489479" >Redis动态字符串SDS源码学习<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C语言存储字符串的问题&quot;&gt;&lt;a href=&quot;#C语言存储字符串的问题&quot; class=&quot;headerlink&quot; title=&quot;C语言存储字符串的问题&quot;&gt;&lt;/a&gt;C语言存储字符串的问题&lt;/h2&gt;&lt;h3 id=&quot;C语言中没有类似Java中的String高级对象&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="Redis" scheme="https://lksun.cn/categories/Redis/"/>
    
    
    <category term="源码" scheme="https://lksun.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Redis数据结构源码解析系列" scheme="https://lksun.cn/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构源码解析(〇) 五大数据类型</title>
    <link href="https://lksun.cn/2022/01/18/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E3%80%87-%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://lksun.cn/2022/01/18/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E3%80%87-%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-01-18T00:00:00.000Z</published>
    <updated>2022-06-30T07:40:17.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文不介绍具体使用，已底层实现为主。先宏观介绍下实现方式具体实现后续文章介绍。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>字符串 String</li><li>列表 List</li><li>集合 Set</li><li>有序集合 ZSet</li><li>哈希 Hash</li></ul><h2 id="数据编码"><a href="#数据编码" class="headerlink" title="数据编码"></a>数据编码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201201105650.png" alt="image-20220120110543608"></p><h3 id="一-、字符串"><a href="#一-、字符串" class="headerlink" title="一 、字符串"></a>一 、字符串</h3><p>使用了三种作为底层的实现：</p><ol><li><p>embstr（OBJ_ENCODING_EMBSTR）</p><p>长度小于44字节的字符串，该编码中 <code>RedisObject</code>、<code>SDS</code>放置在连续的内存中。</p></li><li><p>row（OBJ_ENCODING_RAW）</p><p>长度大于44字节,除此之外与 <code>OBJ_ENCODING_EMBSTR</code>区别仅在于是否为连续内存</p></li><li><p>int（OBJ_ENCODING_INT）</p><p>有时候我们会在String寸INT类型的自然数，例如一个手机号如果为字符串则需要11字节，如果使用long long 只需要8字节。</p></li></ol><p>3中的 <code>Int</code>没什么好说的属于基本数据类型，1和2都涉及到SDS，这也是Redis中很基础的一个对象。</p><h3 id="二-、列表"><a href="#二-、列表" class="headerlink" title="二 、列表"></a>二 、列表</h3><p>使用了三种作为底层的实现：</p><ol><li>双向链表（OBJ_ENCODING_LINKEDLIST）<ul><li>链表节点指针比较多，内存浪费。</li><li>链表会造成内存碎片</li></ul></li><li>压缩列表（OBJ_ENCODING_ZIPLIST）<ul><li>底层为数组实现，解决了内存碎片问题，不需要指针</li><li>当元素很多时，可用内存明明足够，但是因为没有足够大的连续内存而出问题</li><li>数组的新增、删除牵一发动全身，需要整个列表进行数据操作</li></ul></li><li>快速列表（OBJ_ENCODING_ZIPLIST）<ul><li>基于压缩列表和链表实现，解决了压缩列表存在的一些问题，通过分治思想把很大的列表拆分为多个</li></ul></li></ol><p><strong>3.2</strong>版本之后弃用了双向链表改为快速列表。</p><p>那么什么时候使用压缩列表什么时候使用快速列表？</p><ul><li>所有字符串元素的长度都小于 64 字节并且保存的元素数量小于512个的列表使用压缩列表</li><li>存在字符串元素长度大于64或元素个数大于512个使用快速列表</li></ul><h3 id="三、Hash"><a href="#三、Hash" class="headerlink" title="三、Hash"></a>三、Hash</h3><p>使用了两种作为底层的实现：</p><ol><li>字典（哈希表）(OBJ_ENCODING_HT)</li><li>压缩列表（OBJ_ENCODING_ZIPLIST）</li></ol><p>关于两者的选择其实比较简单：</p><blockquote><p>因为压缩列表比字典更节省内存， 所以程序在创建新 Hash 键时， 默认使用压缩列表作为底层实现， 当有需要时， 程序才会将底层实现从压缩列表转换到字典。</p></blockquote><ul><li>总长度超过512字节或者单个元素长度大于64使用字典</li><li>总长度小于512字节或者单个元素长度小于64使用压缩列表</li></ul><h3 id="四、Set"><a href="#四、Set" class="headerlink" title="四、Set"></a>四、Set</h3><p>使用了两种作为底层的实现：</p><ol><li>整数集合 (OBJ_ENCODING_INTSET)</li><li>字典（哈希表）(OBJ_ENCODING_HT)</li></ol><p>关于两者的选择：</p><blockquote><p>Redis没有规定Set可存放的数据类型为什么，可能遇到与String同样的问题。存储一个手机号，使用字符串和long类型内存的占用是完全不一样的。</p><p>真的是能省就省</p></blockquote><ul><li>集合对象保存的所有元素都是整数值且元素数量不超过 <code>512</code> 个使用整数集合</li><li>总长度超过512字节或者单个元素长度大于64的使用字典</li><li>遇到如下情况会立刻发生转换<ul><li>往集合中添加了非整型变量会转换为字典</li></ul></li></ul><h3 id="五、ZSet"><a href="#五、ZSet" class="headerlink" title="五、ZSet"></a>五、ZSet</h3><p>使用了两种作为底层的实现：</p><ol><li>跳跃表（OBJ_ENCODING_SKIPLIST）</li><li>压缩列表（OBJ_ENCODING_ZIPLIST）</li></ol><p>两者的选择也在于内存的使用上：</p><blockquote><p>在大量元素的集合中使用跳跃表可以更快的查询，但是如果数量不多还要存储大量的多层索引会造成内存的浪费。</p></blockquote><ul><li><code>zset</code>会根据 <code>zadd</code>命令添加的第一个元素的长度大小来选择编码方式：满足 <code>zset_max_ziplist_entries</code>的值不为0，第一个元素的长度小于 <code>server.zset_max_ziplist_value</code>，使用压缩列表，否则就是跳跃表。</li><li>待新加的新的字符串长度超过 <code>zset_max_ziplist_value</code>（默认值64）时或者 <code>ziplist</code>保存的节点数量超过 <code>server.zset_max_ziplist_entries</code>（默认值128）时使用skiplist。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>数据类型</th><th>String</th><th>List</th><th>Hash</th><th>Set</th><th>ZSet</th></tr></thead><tbody><tr><td><em><strong>SDS</strong></em></td><td>√</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>快速列表</strong></td><td></td><td>√</td><td></td><td></td><td></td></tr><tr><td><strong>双向链表</strong></td><td></td><td>√</td><td></td><td></td><td></td></tr><tr><td><strong>压缩列表</strong></td><td></td><td>√</td><td>√</td><td></td><td>√</td></tr><tr><td><strong>跳跃表</strong></td><td></td><td></td><td></td><td></td><td>√</td></tr><tr><td><strong>字典（哈希表）</strong></td><td></td><td></td><td>√</td><td>√</td><td></td></tr><tr><td><strong>整数集合</strong></td><td></td><td></td><td></td><td>√</td><td></td></tr></tbody></table><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul><li><a class="link"   href="https://tech.youzan.com/redisyuan-ma-jie-xi/" >Redis源码解析 - 有赞技术团队<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://redisbook.com/index.html" >Redis 设计与实现<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文不介绍具体使用，已底层实现为主。先宏观介绍下实现方式具体实现后续文章介绍。&lt;/p&gt;
&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据</summary>
      
    
    
    
    <category term="Redis" scheme="https://lksun.cn/categories/Redis/"/>
    
    
    <category term="源码" scheme="https://lksun.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Redis数据结构源码解析系列" scheme="https://lksun.cn/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>关于Mysql的江湖传言</title>
    <link href="https://lksun.cn/2022/01/08/%E5%85%B3%E4%BA%8EMysql%E7%9A%84%E6%B1%9F%E6%B9%96%E4%BC%A0%E8%A8%80/"/>
    <id>https://lksun.cn/2022/01/08/%E5%85%B3%E4%BA%8EMysql%E7%9A%84%E6%B1%9F%E6%B9%96%E4%BC%A0%E8%A8%80/</id>
    <published>2022-01-08T18:34:52.000Z</published>
    <updated>2022-06-30T07:40:17.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="谣言粉碎机"><a href="#谣言粉碎机" class="headerlink" title="谣言粉碎机"></a>谣言粉碎机</h1><h2 id="谁说必须遵循最左匹配原则"><a href="#谁说必须遵循最左匹配原则" class="headerlink" title="谁说必须遵循最左匹配原则?"></a>谁说必须遵循最左匹配原则?</h2><p>创建组合索引在查询语句时必须遵循最左匹配原则，即 where 时组合索引的第一个索引列必须在最前面。不然<strong>会索引失效!</strong><br>这是常见的八股文了，原理上没毛病，在B+树上每个非叶子节点不可能逐个比较条件语句，通过组合索引的第一个匹配。但是优化器在执行前会帮助我们调整where 的顺序，开发者不强制顺序，但是最好还是遵循一下。</p><blockquote><p>SELECT * FROM client  WHERE age = 18 AND shop_id = 1<br>SELECT * FROM client  WHERE shop_id = 1 AND age = 18</p></blockquote><p>如上两条SQL，结果一样只是where的顺序不同，组合索引字段设置为 <code>&quot;shop_id &quot;,&quot;age &quot;</code>，如果按照江湖传言最左匹配的话第一条时无法命中索引的，但是通过 <code>EXPLAIN</code>查看，两条语句的结果相同。</p><h2 id="谁说组合索引遇到范围查询就失效？"><a href="#谁说组合索引遇到范围查询就失效？" class="headerlink" title="谁说组合索引遇到范围查询就失效？"></a>谁说组合索引遇到范围查询就失效？</h2><p>在一个组合索引中如：<code>where shop_id = 2 and client_type = 2 and age &gt;18 </code>,即使 <code>&quot;shop_id &quot;,&quot;age &quot;,&quot;client_type &quot;</code>有一个组合索引但是因为 <code>age</code>的范围查询会不走索引。</p><p>首先这是错误的，在MySQL5.6版本后推出了<strong>索引下推</strong>机制，非等值查询也并不会导致索引失效了。</p><h2 id="谁说使用SQL函数会索引失效"><a href="#谁说使用SQL函数会索引失效" class="headerlink" title="谁说使用SQL函数会索引失效?"></a>谁说使用SQL函数会索引失效?</h2><p>查询中不能使用内置的函数否则会索引失效，也是常见的八股文之一了那么事实情况是什么样？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> client <span class="keyword">WHERE</span> shop_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> nick_name <span class="operator">=</span> CONCAT(&quot;雷&quot;,&quot;达&quot;) </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201081833352.png"><br>在如上语句中使用了 <code>CONCAT</code>但是查询计划还是命中索引</p><p>还例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> client <span class="keyword">WHERE</span> shop_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> create_time <span class="operator">=</span> NOW()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201081833573.png"><br>同样使用了索引</p><p>再或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">max</span>(age) <span class="keyword">FROM</span> client <span class="keyword">WHERE</span> shop_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> gmt_create <span class="operator">=</span> NOW()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201081834644.png"></p><ul><li>5.7新增特性:可以使用函数索引</li></ul><h2 id="谁说计算会导致索引失效"><a href="#谁说计算会导致索引失效" class="headerlink" title="谁说计算会导致索引失效?"></a>谁说计算会导致索引失效?</h2><p>还是前面的例子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">max</span>(age) <span class="keyword">FROM</span> client <span class="keyword">WHERE</span> shop_id <span class="operator">=</span> <span class="number">10</span><span class="number">-9</span> <span class="keyword">AND</span> gmt_create <span class="operator">=</span> NOW()</span><br></pre></td></tr></table></figure><p><code>shop_id</code>没有直接写1 ,使用了 10-9，最终的效果时一样的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;谣言粉碎机&quot;&gt;&lt;a href=&quot;#谣言粉碎机&quot; class=&quot;headerlink&quot; title=&quot;谣言粉碎机&quot;&gt;&lt;/a&gt;谣言粉碎机&lt;/h1&gt;&lt;h2 id=&quot;谁说必须遵循最左匹配原则&quot;&gt;&lt;a href=&quot;#谁说必须遵循最左匹配原则&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="MySQL" scheme="https://lksun.cn/categories/MySQL/"/>
    
    
    <category term="造火箭" scheme="https://lksun.cn/tags/%E9%80%A0%E7%81%AB%E7%AE%AD/"/>
    
    <category term="谎言粉碎机" scheme="https://lksun.cn/tags/%E8%B0%8E%E8%A8%80%E7%B2%89%E7%A2%8E%E6%9C%BA/"/>
    
    <category term="MySQL调优" scheme="https://lksun.cn/tags/MySQL%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM 内存结构</title>
    <link href="https://lksun.cn/2022/01/08/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>https://lksun.cn/2022/01/08/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2022-01-08T18:24:34.000Z</published>
    <updated>2022-06-30T07:40:17.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201081819158.png"><br>根据上图我们发现 Java 内存结构由堆、虚拟机栈、方法区、程序计算器、本地方法栈。如果分为两种类型则是：<strong>线程共享的</strong> 和 <strong>线程私有的</strong>。</p><h2 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h2><h3 id="程序计数器（PC-Register）"><a href="#程序计数器（PC-Register）" class="headerlink" title="程序计数器（PC Register）"></a>程序计数器（PC Register）</h3><p>在图中看到了很大一块程序计数器其实在现实中只是开辟了很小很小的一部分，他的核心作用是用于：记录线程执行到的位置。</p><blockquote><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，<strong>为了线程切换后能恢复到正确的执行位置</strong>，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。</p></blockquote><ul><li><strong>程序计数器中只存储当前线程执行程序的行号，一个类指针的数据结构。</strong><br>JVM线程中执行的方法有2种类型：普通Java方法和由其他语言实现的native方法。如果当前执行的是普通Java方法，则程序计数器记录的是<strong>虚拟机字节码指令的地址</strong>。如果当前执行的是native方法，则<strong>计数器的值为空（Undefined）</strong>。</li></ul><h3 id="虚拟机栈（VM-Stack）"><a href="#虚拟机栈（VM-Stack）" class="headerlink" title="虚拟机栈（VM Stack）"></a>虚拟机栈（VM Stack）</h3><blockquote><p>和程序计数器一样，虚拟机栈也是线程私有的，即生命周期和线程相同。</p><p>Java虚拟机栈<strong>和线程同时创建，用于存储栈帧</strong>。每个方法在执行时都会创建一个<strong>栈帧(Stack Frame)，</strong>用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、动态链接、方法出口等信息。每一个方法从调用直到执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<strong>栈帧</strong>：一个栈帧随着一个方法的调用开始而创建，这个方法调用完成而销毁。栈帧内存放者方法中的局部变量，操作数栈等数据。栈帧也叫过程活动记录，是编译器用来实现过程/函数调用的一种数据结构。</p></blockquote><p><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201081820094.png"></p><ul><li><p>栈帧结构</p><ul><li><p>局部变量表<br>局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。并且在Java编译为Class文件时，就已经确定了该方法所需要分配的局部变量表的最大容量。</p></li><li><p>动态连接<br>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支付方法调用过程中的动态连接Dynamic Linking）。<br><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201081820719.png"></p></li><li><p>操作数据栈<br>操作数栈和局部变量表一样，在编译时期就已经确定了该方法所需要分配的局部变量表的最大容量。</p></li><li><p>返回方法当一个方法开始执行后，只有2种方式可以退出这个方法 ：</p><ul><li>方法返回指令 执行引擎遇到一个方法返回的字节码指令，这时候有可能会有返回值传递给上层的方法调用者，这种退出方式称为正常完成出口。</li><li>异常退出 ： 在方法执行过程中遇到了异常，并且没有处理这个异常，就会导致方法退出。</li></ul></li></ul></li></ul><h3 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h3><p>简单来说就是一个java调用非java代码的接口，一般是C或C++代码。至于为什么使用其他语言主要是使用更底层的语言效率更高。</p><h2 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h2><h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><blockquote><p>JAVA堆内存管理是影响性能主要因素之一也是虚拟机管理中心内存最大的一块，在虚拟机启时创建。此内存区域唯一的目的就是存放对象实例，Java中几乎所有的对象实例都在这里分配内存。</p></blockquote><ul><li>下面通过一个图片看一下组成部分：<br><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201081820239.png"></li><li>新生代</li></ul><blockquote><p>新生成的对象首先放到年轻代Eden区，当Eden空间满了，触发Minor GC，存活下来的对象移动到Survivor0区，Survivor0区满后触发执行Minor GC，Survivor0区存活对象移动到Suvivor1区，这样保证了一段时间内总有一个survivor区为空。经过多次Minor GC仍然存活的对象移动到老年代。</p></blockquote><p>结构组成：</p><ul><li>伊甸园区</li><li>幸存者一区</li><li>幸存者二区</li></ul><blockquote><p>💡 新生代特点：每次垃圾回收时都有大量的对象需要被回收。垃圾回收器在新生代采用的收集算法是Copying(复制)方法：它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块面对内存用完了，就将还存活的对象复制到另外一块，然后再把已使用的内存空间一次清理掉。由于新生代有每次垃圾回收时都有大量的对象需要被回收的特点，所以采用Copying算法，复制的存活对象较少，性能比较好。但是Copying算法还是有缺陷的，那就是内存的使用率只有一半。</p></blockquote><ul><li>内存分配</li><li>堆的大小可以通过参数 <code>–Xms</code>、<code>-Xmx</code>来指定。</li><li>新生代 ( Young ) 与老年代 ( Old ) 的默认比例的值为 1:2 ( 该值可以通过参数 <code>–XX:NewRatio</code> 来指定 )</li><li>伊甸区 : 幸存一区 : 幸存二区 = 8 : 1 : 1 ( 可以通过参数 <code>–XX:SurvivorRatio</code> 来设定 )，</li><li>老年代</li></ul><blockquote><p>老年代存储长期存活的对象，占满时会触发Major GC=Full GC，GC期间会停止所有线程等待GC完成，所以对响应要求高的应用尽量减少发生Major GC，避免响应超时。</p></blockquote><ul><li><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201081820628.png"><br><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201081821177.png"></li><li>永久代<br>永久代存放类的常量、静态变量等信息，是方法区的实现。对永久代的回收主要回收两部分内容：废弃常量和无用的类。</li></ul><blockquote><p>💡 注意：JDK1.8 之后，不存在永久带，即没有java.lang.OutOfMemoryError: PermGen space 这种错误。取而代之的是Meta space（元空间）。之前存储在永久带的字符串常量，静态变量移到了堆中去了，元空间不存储在堆中，而是存储在本地内存中。</p></blockquote><h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>方法区是被所有线程共享，所有字段和字节码，以及一些特殊方法如构造器，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间。<br>静态变量 + 常量 + 类信息 + 运行时常量池存在方法区中，实例对象存在堆内存中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/CanonNr/blog-image/master/</summary>
      
    
    
    
    <category term="Java" scheme="https://lksun.cn/categories/Java/"/>
    
    
    <category term="JVM" scheme="https://lksun.cn/tags/JVM/"/>
    
    <category term="造火箭" scheme="https://lksun.cn/tags/%E9%80%A0%E7%81%AB%E7%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>String str = &quot;hello&quot;; 和 String = new String(&quot;hello&quot;); 的区别</title>
    <link href="https://lksun.cn/2022/01/08/hello-%E5%92%8C-String-new-String-hello-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://lksun.cn/2022/01/08/hello-%E5%92%8C-String-new-String-hello-%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-01-08T18:15:54.000Z</published>
    <updated>2022-06-30T07:40:17.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello&quot;</span>; </span><br><span class="line">String = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>); </span><br></pre></td></tr></table></figure><p>如上两个方法都可以得到我们想要的一个字符串，但是区别还是有的.</p><h1 id="堆和常量池的关系"><a href="#堆和常量池的关系" class="headerlink" title="堆和常量池的关系"></a>堆和常量池的关系</h1><ul><li><strong>堆（Heap）</strong></li></ul><p>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Heap是被所有线程共享的一块内存区域，在虚拟机启动时被创建。<br>Heap的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配内存。</p><ul><li><strong>字符串常量池</strong></li></ul><p>在jdk1.7之前的版本中，字符串常量池是存在于永久代中，在永久代和堆中的地址是完全分离的，不会直接引用。<br>在jdk1.7+之后的版本中，字符串常量池被放在了堆中。</p><h1 id="声明一个字符串"><a href="#声明一个字符串" class="headerlink" title="声明一个字符串"></a>声明一个字符串</h1><h2 id="String-Str1-“hello”"><a href="#String-Str1-“hello”" class="headerlink" title="String Str1 = “hello”;"></a>String Str1 = “hello”;</h2><h3 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h3><p><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201081816419.png"><br>对于str1来说，由于是常量赋值，str1直接指向字符串常量池中的数据，并且只有一份。</p><h2 id="String-str2-new-String-“hello”"><a href="#String-str2-new-String-“hello”" class="headerlink" title="String str2 = new String(“hello”);"></a>String str2 = new String(“hello”);</h2><h3 id="内存分布-1"><a href="#内存分布-1" class="headerlink" title="内存分布"></a>内存分布</h3><p><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201081817903.png"><br><code>String str2 = new String(&quot;ab&quot;);</code>在执行过程中，JVM首先在字符串常量池中查看字符串对象“ab”是否存在，<strong>若不存在，则现在字符串常量池中创建“ab”对象，然后再Heap中创建一个新的“ab”字符串对象</strong>。<br>若字符串常量池中已经存在了字符串对象“ab”，则直接在堆中创建一个字符串对象“ab”，不许在字符串常量池中创建对象，但是不管是那种方式，栈中的str2始终指向的是Heap中的字符串对象。<br>若字符串常量池中原本没有“ab”对象，String str2 = new String(“ab”);执行后会在字符串常量池和堆中各创建一个对象，即创建两个对象，若字符串常量池中已存在了“ab”对象，则只会在Heap中创建，即只创建了一个对象。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;rush b&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;rush b&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">// return true</span></span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">// return true</span></span><br><span class="line">System.out.println(System.identityHashCode(str1)); <span class="comment">// return 1163157884</span></span><br><span class="line">System.out.println(System.identityHashCode(str2)); <span class="comment">// return 1163157884</span></span><br></pre></td></tr></table></figure><p><code>str1</code> 和 <code>str2</code> 是完全不同的两个变量，在栈空间中地址是不同的，但是通过 <code>System.identityHashCode</code>发现他们其实也相同。如下图所示。<br><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201081817830.png"></p><h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str1 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">String str2 = str1.intern();</span><br><span class="line">System.out.println(str1 == str2); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/CanonNr/blog-image/master/img/202201081817412.png"></p><blockquote><p>代码非常简单，str1就是最普通的常量赋值，会直接在字符串常量池中创建出”ab”对象 str1调用intern方法得到返回值赋值给str2，intern方法会现在字符串常量池中检测是否已经存在”ab”字符串对象，若已经存在，直接把字符串常量池里”ab”对象的地址赋值给str2，所以str1==str2为true。</p></blockquote><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>作者：saojiatete<br>链接：<a class="link"   href="https://juejin.cn/post/6844904015830974472" >https://juejin.cn/post/6844904015830974472<i class="fas fa-external-link-alt"></i></a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c</summary>
      
    
    
    
    <category term="Java" scheme="https://lksun.cn/categories/Java/"/>
    
    
    <category term="JVM" scheme="https://lksun.cn/tags/JVM/"/>
    
    <category term="造火箭" scheme="https://lksun.cn/tags/%E9%80%A0%E7%81%AB%E7%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>Java new 一个对象都经历了什么</title>
    <link href="https://lksun.cn/2022/01/08/Java-new-%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://lksun.cn/2022/01/08/Java-new-%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2022-01-08T18:13:18.000Z</published>
    <updated>2022-06-30T07:40:17.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Java在new一个对象的时候，会先查看对象所属的类有没有被加载到内存，如果没有的话，就会先通过类的全限定名来加载。加载并初始化类完成后，再进行对象的创建工作。<br>由此得出一个new一个java对象包括两个过程：加载和创建</p></blockquote><h1 id="加载类"><a href="#加载类" class="headerlink" title="加载类"></a>加载类</h1><blockquote><p>java是使用双亲委派模型来进行类的加载的，具体查看双亲委派的笔记。</p></blockquote><h2 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h2><p>由类加载器负责根据一个类的<strong>全限定类名</strong>来读取此类的<strong>二进制字节流</strong>到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例<br>​</p><h2 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h2><ul><li>格式验证：验证是否符合class文件规范<ul><li>是否以<strong>0xCAFEBABE</strong>开头</li><li>主、次版本号是否在当前虚拟机的处理范围之内</li></ul></li></ul><h2 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h2><p>在方法区内<strong>为类静态变量分配内存并将其初始化为默认值</strong>。<br>被 <code>final</code> 修饰的 <code>static</code> 变量（常量），会<strong>直接赋值</strong>。</p><h2 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h2><p>解析阶段是虚拟机将常量池内的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程。</p><ul><li><p>符号引用：字符串类型的引用，能根据这个字符串定位到指定的对象，如：<code>java/lang/StringBuilder</code></p></li><li><p>直接引用：内存地址</p><h2 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h2></li><li><p>初始化是指<strong>为类静态变量赋予正确的初始值</strong>，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li>声明类变量时指定初始值；</li><li>使用静态代码块为类变量指定初始值。</li></ul></li><li><p>执行static代码块</p><blockquote><p><code>static</code> 代码块只有jvm能够调用;<br>如果 <code>static</code> 代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。**</p></blockquote></li></ul><h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><h2 id="1-在堆区分配对象需要的内存"><a href="#1-在堆区分配对象需要的内存" class="headerlink" title="1.在堆区分配对象需要的内存"></a>1.<strong>在堆区分配对象需要的内存</strong></h2><p>分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量</p><h2 id="2-对所有实例变量赋默认值"><a href="#2-对所有实例变量赋默认值" class="headerlink" title="2.对所有实例变量赋默认值"></a>2.对所有实例变量赋默认值</h2><p>将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值</p><h2 id="3-执行实例初始化代码"><a href="#3-执行实例初始化代码" class="headerlink" title="3.执行实例初始化代码"></a>3.执行实例初始化代码</h2><p>初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法</p><h2 id="4-定义栈变量"><a href="#4-定义栈变量" class="headerlink" title="4.定义栈变量"></a>4.定义栈变量</h2><p>如果new的对象会赋值给一个变量，则会在栈区内定义一个该类型的引用变量，然后将堆区的对象地址赋予它。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java在new一个对象的时候，会先查看对象所属的类有没有被加载到内存，如果没有的话，就会先通过类的全限定名来加载</summary>
      
    
    
    
    <category term="Java" scheme="https://lksun.cn/categories/Java/"/>
    
    
    <category term="JVM" scheme="https://lksun.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock 公平锁与非公平锁</title>
    <link href="https://lksun.cn/2022/01/06/ReentrantLock%20%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/"/>
    <id>https://lksun.cn/2022/01/06/ReentrantLock%20%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/</id>
    <published>2022-01-06T15:51:45.000Z</published>
    <updated>2022-06-30T07:40:17.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h1><p>在实例化 <code>ReentrantLock</code> 的时候可以加一个构造参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传true时为公平锁</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure><p>当然他们的构造方法也是不一样的</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fair为true时为公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此事我们发现 <code>ReentrantLock</code> 为了应对公平锁与非公平锁实现了两个类： <code>FairSync</code> 和 <code>NonfairSync</code> 。他们都是继承于 <code>Sync</code> 类。</p><h1 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h1><p>我们找到 <code>FairSync</code> 和 <code>NonfairSync</code>  类的 <code>lock</code> 方法，发现区别还是很明显的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 发现非公平锁比公平锁多了一步</span></span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">             setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             acquire(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>公平锁在执行 <code>lock</code> 方法时会直接执行 <code>acquire</code> 方法，而非公平锁会先尝试替换一下状态，如果成功则设置当前线程为所有者。</p><h1 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>貌似很多，是否公平的关键只是一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非公平</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公平</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 多了一个hasQueuedPredecessors</span></span><br><span class="line">    <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">        compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="hasQueuedPredecessors"><a href="#hasQueuedPredecessors" class="headerlink" title="hasQueuedPredecessors"></a>hasQueuedPredecessors</h1><p>翻译过来就是队列是否有前节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头节点不是尾节点 且 （ 头节点的下一个节点不为空 或者 头节点的下一个节点不是当前节点 ）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实例化&quot;&gt;&lt;a href=&quot;#实例化&quot; class=&quot;headerlink&quot; title=&quot;实例化&quot;&gt;&lt;/a&gt;实例化&lt;/h1&gt;&lt;p&gt;在实例化 &lt;code&gt;ReentrantLock&lt;/code&gt; 的时候可以加一个构造参数。&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    <category term="Java" scheme="https://lksun.cn/categories/Java/"/>
    
    
    <category term="多线程与高并发系列" scheme="https://lksun.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97/"/>
    
    <category term="AQS" scheme="https://lksun.cn/tags/AQS/"/>
    
    <category term="锁" scheme="https://lksun.cn/tags/%E9%94%81/"/>
    
    <category term="ReentrantLock" scheme="https://lksun.cn/tags/ReentrantLock/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock 如何保证重入</title>
    <link href="https://lksun.cn/2022/01/06/ReentrantLock%20%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%87%8D%E5%85%A5/"/>
    <id>https://lksun.cn/2022/01/06/ReentrantLock%20%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%87%8D%E5%85%A5/</id>
    <published>2022-01-06T15:51:43.000Z</published>
    <updated>2022-06-30T07:40:17.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="公平锁："><a href="#公平锁：" class="headerlink" title="公平锁："></a>公平锁：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">setExclusiveOwnerThread(current);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"><span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line"><span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">setState(nextc);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非公平锁："><a href="#非公平锁：" class="headerlink" title="非公平锁："></a>非公平锁：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires))&#123;</span><br><span class="line">setExclusiveOwnerThread(current);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"><span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line"><span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">setState(nextc);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面这两段都可以看到，有一个同步状态State来控制整体可重入的情况。<code>State</code>是 <code>Volatile</code>修饰的，用于保证一定的可见性和有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>接下来看 <code>State</code>这个字段主要的过程：</p><ol><li><strong><code>State</code>初始化的时候为0，表示没有任何线程持有锁。</strong></li><li><strong>当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。</strong></li><li><strong>解锁也是对这个字段-1，一直到0，此线程对锁释放。</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;公平锁：&quot;&gt;&lt;a href=&quot;#公平锁：&quot; class=&quot;headerlink&quot; title=&quot;公平锁：&quot;&gt;&lt;/a&gt;公平锁：&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    <category term="Java" scheme="https://lksun.cn/categories/Java/"/>
    
    
    <category term="多线程与高并发系列" scheme="https://lksun.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97/"/>
    
    <category term="AQS" scheme="https://lksun.cn/tags/AQS/"/>
    
    <category term="锁" scheme="https://lksun.cn/tags/%E9%94%81/"/>
    
    <category term="ReentrantLock" scheme="https://lksun.cn/tags/ReentrantLock/"/>
    
  </entry>
  
</feed>
